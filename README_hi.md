<h1 align="center">Computer Science</h1>
<h4 align="center">
    <p>
        <b>English</b> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_es.md">Español</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_fr.md">Français</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_bn.md">বাংলা</a>
        <a href="https://github.com/shhossain/computer_science/blob/main/README_hi.md">हिन्दी</a>
    </p>
</h4>
## विषय-सूची

- [परिचय](#परिचय)
- [इलेक्ट्रॉनिक कंप्यूटर](#इलेक्ट्रॉनिक कंप्यूटर)
- [बुलियन तर्क](#बुलियन तर्क)
- [संख्या प्रणाली](#संख्या प्रणाली)
- [केंद्रीय प्रसंस्करण इकाई (CPU))](#केंद्रीय प्रसंस्करण इकाई (CPU))
- [रजिस्टर, कैश और रैम](#रजिस्टर, कैश और रैम)
- [निर्देश और कार्यक्रम](#निर्देश और कार्यक्रम)
- [प्रोग्रामिंग भाषाएँ](#प्रोग्रामिंग भाषाएँ)
- [डेटा प्रकार](#डेटा प्रकार)
- [कथन और फ़ंक्शन](#कथन और फ़ंक्शन)
- [डेटा संरचनाएँ](#डेटा संरचनाएँ)
- [अल्गोरिदम](#अल्गोरिदम)
- [एलन ट्यूरिंग](#एलन ट्यूरिंग)
- [सॉफ्टवेयर इंजीनियरिंग](#सॉफ्टवेयर इंजीनियरिंग)
- [एकीकृत सर्किट](#एकीकृत सर्किट)
- [ऑब्जेक्ट-ओरिएंटेड प्रोग्रामिंग](#ऑब्जेक्ट-ओरिएंटेड प्रोग्रामिंग)
- [फ़ंक्शनल प्रोग्रामिंग](#फ़ंक्शनल प्रोग्रामिंग)
- [ऑपरेटिंग सिस्टम](#ऑपरेटिंग सिस्टम)
- [मेमोरी और स्टोरेज](#मेमोरी और स्टोरेज)
- [फ़ाइल सिस्टम](#फ़ाइल सिस्टम)
- [क्लाउड कंप्यूटिंग](#क्लाउड कंप्यूटिंग)
- [मशीन लर्निंग](#मशीन लर्निंग)
- [वेब प्रौद्योगिकी](#वेब प्रौद्योगिकी)
- [नेटवर्किंग](#नेटवर्किंग)
- [इंटरनेट](#इंटरनेट)
- [DBMS (डेटाबेस प्रबंधन प्रणाली)](#dbms)
- [क्रिप्टोग्राफी](#क्रिप्टोग्राफी)
- [संगणना सिद्धांत](#संगणना सिद्धांत)


## परिचय

कंप्यूटर विज्ञान कंप्यूटर और गणना और उनके सैद्धांतिक और व्यावहारिक अनुप्रयोगों का अध्ययन है। कंप्यूटर विज्ञान गणित, इंजीनियरिंग और तर्क के सिद्धांतों को समस्याओं की एक विस्तृत श्रृंखला में लागू करता है। इनमें एल्गोरिदम निर्माण, सॉफ़्टवेयर/हार्डवेयर विकास और कृत्रिम बुद्धिमत्ता शामिल हैं।


## [इलेक्ट्रॉनिक कंप्यूटर](Electronic%20Computer/readme.md)
एक उपकरण जो गणना करता है, विशेष रूप से एक प्रोग्रामेबल इलेक्ट्रॉनिक मशीन जो उच्च गति के गणितीय या तार्किक ऑपरेशन करता है या जानकारी को एकत्र करता है, संग्रहीत करता है, सहसंबंधित करता है या अन्यथा संसाधित करता है।

## [बूलियन तर्क](Boolean%20Logic/readme.md)
बुलियन तर्क गणित की एक शाखा है जो सत्य और असत्य के मूल्यों से संबंधित है। यह एक ऐसी तर्क प्रणाली है जो केवल दो मानों, 0 और 1 का उपयोग करके, क्रमशः असत्य और सत्य का प्रतिनिधित्व करती है। इसे बूलियन बीजगणित के रूप में भी जाना जाता है, जिसका नाम जॉर्ज बोले के नाम पर रखा गया है, जिन्होंने इसे पहली बार 1854 में वर्णित किया था।

### सामान्य बूलियन ऑपरेटर
| ऑपरेटर | नाम |               विवरण               |
| :------: | :--: | :-------------------------------------: |
|    !     | NOT  |    ऑपरेंड के मान को नकारता है।    |
|    &&    | AND  | यदि दोनों ऑपरेंड सत्य हैं तो true रिटर्न करता है। |
|   \|\|   |  OR  | यदि एक या सभी ऑपरेंड सत्य हैं तो true रिटर्न करता है। |

### बूलियन ऑपरेटर जिन्हें जानना अच्छा है
| ऑपरेटर | नाम |               विवरण                |
| :------: | :--: | :-------------------------------------: |
|    ()    | कोष्ठक     |   कीवर्ड को समूहित करने और उन शब्दों को खोजने के क्रम को नियंत्रित करने की अनुमति देता है    |
|    “”    | उद्धरण चिह्न | सटीक वाक्यांश के साथ परिणाम प्रदान करता है. |
|   *      |  तारांकन       | कीवर्ड परिवर्तन वाले परिणाम प्रदान करता है |
|   ⊕     |  XOR            | ऑपरेंड्स अलग होने पर **true** देता है |
|   ⊽      |  NOR            | सभी ऑपरेंड्स गलत होने पर **true** देता है |
|   ⊼      |  NAND           | केवल तभी **false** देता है जब उसके दो इनपुट के दोनों मान सही हों

## [संख्या प्रणाली](Number%20System/readme.md#number-systems)
संख्या प्रणाली गणितीय प्रणालियाँ हैं संख्याओं को व्यक्त करने के लिए। संख्या प्रणाली में संख्याओं का प्रतिनिधित्व करने के लिए उपयोग किए जाने वाले प्रतीकों का एक सेट और उन प्रतीकों को संभालने के लिए नियमों का एक सेट शामिल होता है। संख्या प्रणाली में उपयोग किए जाने वाले प्रतीकों को अंक कहा जाता है।

### [संख्या प्रणाली के प्रकार](Number%20System/readme.md#types-of-number-systems)
- [स्थितीय अंक प्रणाली](Number%20System/readme.md#positional-numeral-system)
- [साइन-वैल्यू नोटेशन सिस्टम](Number%20System/readme.md#sign-value-notation-system)

### [सामान्य स्थितीय संख्या प्रणालियाँ](Number%20System/readme.md#common-positional-number-systems)
- [बाइनरी](Number%20System/readme.md#binary)
- [ऑक्टल](Number%20System/readme.md#octal)
- [दशमलव](Number%20System/readme.md#decimal)
- [हेक्साडेसिमल](Number%20System/readme.md#hexadecimal)


### बाइनरी का महत्व
बाइनरी एक आधार-2 संख्या प्रणाली है जिसे गॉटफ्रीड लीबनिज़ द्वारा आविष्कार किया गया था, जिसमें केवल दो संख्याएँ या अंक होते हैं: 0 (शून्य) और 1 (एक)। यह संख्या प्रणाली सभी बाइनरी कोड का आधार है, जिसका उपयोग कंप्यूटर प्रोसेसर निर्देशों जैसे डिजिटल डेटा लिखने के लिए किया जाता है जो हर दिन उपयोग किए जाते हैं। बाइनरी में 0 और 1 क्रमशः ऑफ या ऑन का प्रतिनिधित्व करते हैं। एक ट्रांजिस्टर में, एक "0" बिजली के प्रवाह की अनुपस्थिति का प्रतिनिधित्व करता है, और एक "1" बिजली के प्रवाह की अनुमति देता है। इस तरह, संख्याएँ कंप्यूटिंग डिवाइस के अंदर भौतिक रूप से दर्शाई जाती हैं, जिससे गणना की अनुमति मिलती है।

 
बाइनरी अभी भी कंप्यूटरों के लिए प्राथमिक भाषा है और इलेक्ट्रॉनिक्स और कंप्यूटर हार्डवेयर के साथ निम्नलिखित कारणों से उपयोग किया जाता है:

- यह एक सरल और सुंदर डिज़ाइन है।
- बाइनरी का 0 और 1 तरीका एक विद्युत सिग्नल के बंद (झूठा) या चालू (सच्चा) राज्य का पता लगाने में तेज़ है।
- विद्युत सिग्नल में दो राज्यों को बहुत दूर रखने से यह विद्युत हस्तक्षेप के प्रति कम संवेदनशील हो जाता है।
- चुंबकीय मीडिया के धनात्मक और ऋणात्मक ध्रुवों को जल्दी से बाइनरी में अनुवादित किया जाता है।
- बाइनरी तर्क सर्किट को नियंत्रित करने का सबसे कुशल तरीका है।



## [सेन्ट्रल प्रॉसेसिंग यूनिट (सीपीयू)](CPU/readme.md#central-processing-unitcpu)
केंद्रीय प्रसंस्करण इकाई (CPU) किसी भी कंप्यूटर का सबसे महत्वपूर्ण हिस्सा है। CPU अन्य कंप्यूटर भागों को नियंत्रित करने के लिए सिग्नल भेजता है, ठीक उसी तरह जैसे मस्तिष्क शरीर को नियंत्रित करता है। CPU एक इलेक्ट्रॉनिक मशीन है जो निर्देशों के एक सूची पर काम करती है, जिसे निर्देश कहा जाता है। यह निर्देशों की सूची को पढ़ता है और प्रत्येक को क्रम में चलाता है (निष्पादित करता है)। CPU द्वारा चलाए जा सकने वाले निर्देशों की एक सूची एक कंप्यूटर प्रोग्राम है। CPU एक समय में एक से अधिक निर्देशों को "कोर" नामक खंडों पर संसाधित कर सकता है। चार कोर वाला CPU एक साथ चार प्रोग्रामों को संसाधित कर सकता है। CPU स्वयं तीन मुख्य घटकों से बना है। 
CPU के तीन मुख्य घटक हैं:
1. [मेमोरी या स्टोरेज यूनिट](CPU/readme.md#memory-or-storage-unit)
2. [कंट्रोल यूनिट](CPU/readme.md#control-unit)
3. [अंकगणित और तर्क इकाई (ALU)](CPU/readme.md#arithmetic-and-logic-unit-alu)


## [रजिस्टर, कैश और रैम](/Registers%20Cache%20and%20RAM)

### [रजिस्टर](/Registers%20Cache%20and%20RAM/readme.md#register)
रजिस्टर CPU के भीतर निहित उच्च गति वाली मेमोरी की छोटी मात्रा होती है। रजिस्टर "फ्लिप-फ्लॉप्स" (1 बिट मेमोरी को संग्रहीत करने के लिए उपयोग किया जाने वाला सर्किट) का एक संग्रह है। वे प्रोसेसर द्वारा प्रसंस्करण के दौरान आवश्यक छोटी मात्रा में डेटा को संग्रहीत करने के लिए उपयोग किए जाते हैं। CPU में कई सेट रजिस्टर हो सकते हैं जिन्हें "कोर" कहा जाता है। रजिस्टर अंकगणित और तार्किक क्रियाओं में भी मदद करता है।

अंकगणितीय क्रियाएं संख्यात्मक डेटा पर गणितीय गणनाएं हैं जो CPU द्वारा रजिस्टरों में संग्रहीत की जाती हैं। इन क्रियाओं में योग, घटाव, गुणा और भाग शामिल हैं। तार्किक क्रियाएं बाइनरी डेटा पर बूलियन गणनाएं हैं जो CPU द्वारा रजिस्टरों में संग्रहीत की जाती हैं। इन क्रियाओं में तुलनाएं (उदाहरण के लिए, यह परीक्षण करना कि दो मान बराबर हैं) और तार्किक क्रियाएं (उदाहरण के लिए, AND, OR, NOT) शामिल हैं।

रजिस्टर इन क्रियाओं को करने के लिए आवश्यक हैं क्योंकि वे CPU को छोटे डेटा की मात्रा को जल्दी से एक्सेस और मैनिपुलेट करने की अनुमति देते हैं। बार-बार एक्सेस किए जाने वाले डेटा को रजिस्टरों में संग्रहीत करके, CPU मेमोरी से डेटा प्राप्त करने की धीमी प्रक्रिया से बच सकता है।

बड़े डेटा की मात्रा को कैश (cash) में संग्रहीत किया जा सकता है, जो रजिस्टरों के समान एकीकृत सर्किट पर स्थित एक बहुत तेज मेमोरी है। कैश का उपयोग प्रोग्राम के चलने के दौरान बार-बार एक्सेस किए जाने वाले डेटा के लिए किया जाता है। RAM में भी बड़े डेटा की मात्रा को संग्रहीत किया जा सकता है। RAM का अर्थ है रैंडम-एक्सेस मेमोरी, जो एक प्रकार की मेमोरी है जो डेटा और निर्देशों को डिस्क स्टोरेज से तब तक रखती है जब तक कि प्रोसेसर को इसकी आवश्यकता नहीं होती है।

### [कैश](/Registers%20Cache%20and%20RAM/readme.md#cache)
कैश मेमोरी एक चिप-आधारित कंप्यूटर घटक है जो कंप्यूटर की मेमोरी से डेटा को पुनर्प्राप्त करने को अधिक कुशल बनाता है। यह एक अस्थायी भंडारण क्षेत्र के रूप में कार्य करता है ताकि कंप्यूटर के प्रोसेसर डेटा को आसानी से पुनर्प्राप्त कर सकें। यह अस्थायी भंडारण क्षेत्र, जिसे कैश के रूप में जाना जाता है, कंप्यूटर की मुख्य मेमोरी स्रोत, आमतौर पर कुछ प्रकार के DRAM की तुलना में प्रोसेसर के लिए अधिक आसानी से उपलब्ध होता है।

कैश मेमोरी को कभी-कभी CPU (केंद्रीय प्रसंस्करण इकाई) मेमोरी भी कहा जाता है क्योंकि यह आमतौर पर सीधे CPU चिप में एकीकृत होता है या एक अलग चिप पर रखा जाता है जिसमें CPU के साथ एक अलग बस इंटरकनेक्ट होता है। इसलिए, यह प्रोसेसर के लिए अधिक सुलभ है और दक्षता में वृद्धि करने में सक्षम है क्योंकि यह भौतिक रूप से प्रोसेसर के पास है।

प्रोसेसर के पास होने के लिए, कैश मेमोरी मुख्य मेमोरी की तुलना में बहुत छोटी होनी चाहिए। परिणामस्वरूप, इसमें कम भंडारण स्थान है। यह मुख्य मेमोरी की तुलना में अधिक महंगा भी है, क्योंकि यह एक अधिक जटिल चिप है जो उच्च प्रदर्शन प्रदान करती है।

जिस चीज को यह आकार और कीमत में बलिदान करता है, वह इसे गति में बना देता है। कैश मेमोरी RAM की तुलना में 10 से 100 गुना तेजी से काम करती है, और CPU अनुरोध का जवाब देने के लिए केवल कुछ नैनोसेकंड का समय लेती है।

कैश मेमोरी के लिए उपयोग किए जाने वाले वास्तविक हार्डवेयर का नाम हाई-स्पीड स्टेटिक रैंडम एक्सेस मेमोरी (SRAM) है। कंप्यूटर की मुख्य मेमोरी में उपयोग किए जाने वाले हार्डवेयर का नाम गतिशील रैंडम एक्सेस मेमोरी (DRAM) है।

कैश मेमोरी को व्यापक शब्द कैश के साथ भ्रमित नहीं किया जाना चाहिए। कैश अस्थायी डेटा भंडार हैं जो हार्डवेयर और सॉफ़्टवेयर दोनों में मौजूद हो सकते हैं। कैश मेमोरी उस विशिष्ट हार्डवेयर घटक को संदर्भित करता है जो कंप्यूटरों को नेटवर्क के विभिन्न स्तरों पर कैश बनाने की अनुमति देता है। एक कैश एक हार्डवेयर या सॉफ़्टवेयर है जिसका उपयोग किसी चीज़ को, आमतौर पर डेटा को, कंप्यूटिंग वातावरण में अस्थायी रूप से संग्रहीत करने के लिए किया जाता है।


### [रैम](/Registers%20Cache%20and%20RAM/readme.md#ram)
RAM (रैंडम एक्सेस मेमोरी) कंप्यूटर मेमोरी का एक रूप है जिसे किसी भी क्रम में पढ़ा और बदला जा सकता है, आमतौर पर काम करने वाले डेटा और मशीन कोड को स्टोर करने के लिए उपयोग किया जाता है। एक रैंडम एक्सेस मेमोरी डिवाइस डेटा आइटम्स को मेमोरी के अंदर भौतिक स्थान की परवाह किए बिना लगभग समान समय में पढ़ा या लिखा सकता है, जबकि अन्य प्रत्यक्ष-पहुंच डेटा संग्रहण माध्यमों (जैसे हार्ड डिस्क, सीडी-RW, डीवीडी-RW और पुराने चुंबकीय टेप और ड्रम मेमोरी) में, डेटा आइटम्स को पढ़ने और लिखने में लगने वाला समय उनकी भौतिक स्थिति के आधार पर काफी भिन्न होता है। रिकॉर्डिंग माध्यम पर, यांत्रिक सीमाओं के कारण जैसे मीडिया रोटेशन स्पीड और आर्म मूवमेंट।


## [निर्देश एवं कार्यक्रम](Not-Added)
कंप्यूटर विज्ञान में, एक निर्देश प्रोसेसर का एक एकल ऑपरेशन है जो प्रोसेसर निर्देश सेट द्वारा परिभाषित किया गया है। एक कंप्यूटर प्रोग्राम निर्देशों की एक सूची है जो कंप्यूटर को क्या करना है, यह बताता है। एक कंप्यूटर जो कुछ भी करता है, वह कंप्यूटर प्रोग्राम का उपयोग करके पूरा किया जाता है। कंप्यूटर की मेमोरी में संग्रहीत प्रोग्राम ("आंतरिक प्रोग्रामिंग") कंप्यूटर को एक के बाद एक काम करने देते हैं, यहां तक ​​कि बीच में ब्रेक के साथ भी।

## [प्रोग्रामिंग भाषा](/Programming_Languages/readme.md)

एक प्रोग्रामिंग भाषा नियमों का एक समूह है जो स्ट्रिंग्स, या दृश्य प्रोग्रामिंग भाषाओं के मामले में ग्राफिकल प्रोग्राम तत्वों को विभिन्न प्रकार के मशीन कोड आउटपुट में परिवर्तित करता है। प्रोग्रामिंग भाषाएं कंप्यूटर प्रोग्रामिंग में एल्गोरिदम को लागू करने के लिए उपयोग की जाने वाली एक प्रकार की कंप्यूटर भाषा हैं।

प्रोग्रामिंग भाषाओं को अक्सर दो व्यापक श्रेणियों में विभाजित किया जाता है:

1. उच्च-स्तरीय भाषा अंग्रेजी भाषा के समान एक सिंटैक्स का उपयोग करती है। स्रोत कोड को एक कंपाइलर या एक दुभाषिया का उपयोग करके मशीन द्वारा समझने योग्य मशीन कोड में परिवर्तित किया जाता है। जावा और पायथन उच्च-स्तरीय प्रोग्रामिंग भाषाओं के कुछ उदाहरण हैं। ये आमतौर पर निम्न-स्तरीय भाषाओं की तुलना में धीमे होते हैं, लेकिन ये आसान होते हैं।
2. निम्न-स्तरीय प्रोग्रामिंग भाषाएं हार्डवेयर के साथ अधिक निकटता से काम करती हैं और उस पर अधिक नियंत्रण रखती हैं। वे सीधे हार्डवेयर के साथ बातचीत करते हैं। मशीन भाषा और असेंबली भाषा निम्न-स्तरीय भाषाओं के दो सामान्य उदाहरण हैं। ये आमतौर पर उच्च-स्तरीय भाषाओं की तुलना में तेज होते हैं, लेकिन इसकी कीमत बहुत बड़ी कठिनाई और पठनीयता की कमी के रूप में होती है।

उदाहरण के लिए, मशीन भाषा सीधे कंप्यूटर के हार्डवेयर को निर्देश देती है कि क्या करना है, जबकि उच्च-स्तरीय भाषा जैसे जावा प्रोग्राम को मशीन कोड में परिवर्तित करने के लिए एक कंपाइलर का उपयोग करती है।

### [प्रोग्रामिंग प्रतिमान](/Programming_Languages/readme.md#Programming+Paradigms)
कई अलग-अलग *प्रोग्रामिंग प्रतिमान* भी हैं। प्रोग्रामिंग प्रतिमान विभिन्न तरीके या शैलियाँ हैं जिनमें किसी दिए गए प्रोग्राम या प्रोग्रामिंग भाषा को व्यवस्थित किया जा सकता है। प्रत्येक प्रतिमान में कुछ संरचनाएँ, विशेषताएँ और राय शामिल होती हैं कि सामान्य प्रोग्रामिंग समस्याओं को कैसे संबोधित किया जाना चाहिए।

प्रोग्रामिंग प्रतिमान भाषाएं या उपकरण *नहीं* हैं। आप किसी प्रतिमान के साथ कुछ भी "निर्माण" नहीं कर सकते। वे आदर्शों और दिशानिर्देशों के एक समूह की तरह हैं जिन पर कई लोग सहमत हुए हैं, उनका पालन किया है और उनका विस्तार किया है। प्रोग्रामिंग भाषाएं हमेशा किसी विशेष प्रतिमान से बंधी नहीं होती हैं। ऐसी *भाषाएँ* हैं जो एक निश्चित प्रतिमान को ध्यान में रखकर बनाई गई हैं और उनमें ऐसी विशेषताएं हैं जो दूसरों की तुलना में उस तरह की प्रोग्रामिंग को अधिक सुविधाजनक बनाती हैं (हास्केल और कार्यात्मक प्रोग्रामिंग एक अच्छा उदाहरण है)। लेकिन ऐसी "बहु-प्रतिमान" भाषाएं भी हैं जिनमें आप अपने कोड को एक निश्चित प्रतिमान या अन्य में फिट करने के लिए अनुकूलित कर सकते हैं (जावास्क्रिप्ट और पायथन अच्छे उदाहरण हैं)।


## [डेटा के प्रकार](Data%20Types/readme.md#data-types)
प्रोग्रामिंग में डेटा प्रकार, एक वर्गीकरण है जो निर्दिष्ट करता है कि एक चर का किस प्रकार का मान है और बिना किसी त्रुटि के किस प्रकार के गणितीय, संबंधपरक या तार्किक संचालन को उस पर लागू किया जा सकता है।

### [आदिम डेटा प्रकार](Data%20Types/readme.md#primitive-data-types)
किसी प्रोग्रामिंग भाषा में आदिम डेटा प्रकार सबसे बुनियादी डेटा प्रकार हैं। वे अधिक जटिल डेटा प्रकारों के निर्माण खंड हैं। आदिम डेटा प्रकार प्रोग्रामिंग भाषा द्वारा पूर्वनिर्धारित होते हैं और एक आरक्षित कीवर्ड द्वारा नामित होते हैं।

### [सामान्य आदिम डेटा प्रकार](Data%20Types/readme.md#common-primitive-data-types)
- [पूर्णांक](Data%20Types/readme.md#integer)
- [फ्लोट](Data%20Types/readme.md#float)
- [बूलियन](Data%20Types/readme.md#boolean)
- [चरित्र](Data%20Types/readme.md#character)
- [स्ट्रिंग](Data%20Types/readme.md#string)

### [गैर-आदिम डेटा प्रकार](Data%20Types/readme.md#non-primitive-data-types)
गैर-आदिम डेटा प्रकारों को संदर्भ डेटा प्रकार के रूप में भी जाना जाता है। वे प्रोग्रामर द्वारा बनाए जाते हैं और प्रोग्रामिंग भाषा द्वारा परिभाषित नहीं होते हैं। गैर-आदिम डेटा प्रकारों को समग्र डेटा प्रकार भी कहा जाता है क्योंकि वे अन्य प्रकारों से बने होते हैं।

### [सामान्य गैर-आदिम डेटा प्रकार](Data%20Types/readme.md#common-non-primitive-data-types)
- [सरणी](Data%20Types/readme.md#array)
- [संरचना](Data%20Types/readme.md#struct)
- [संघ](Data%20Types/readme.md#union)
- [सूचक](Data%20Types/readme.md#pointer)
- [फ़ंक्शन](Data%20Types/readme.md#function)
- [कक्षा](Data%20Types/readme.md#class)

## [कथन और कार्य](Statements%20and%20Functions/readme.md)
कंप्यूटर प्रोग्रामिंग में, एक स्टेटमेंट एक अनिवार्य प्रोग्रामिंग भाषा की एक वाक्यात्मक इकाई है जो किए जाने वाले कुछ कार्यों को व्यक्त करती है। ऐसी भाषा में लिखा गया प्रोग्राम एक या अधिक कथनों के अनुक्रम से बनता है। किसी कथन में आंतरिक घटक (जैसे, अभिव्यक्ति) हो सकते हैं।
किसी भी प्रोग्रामिंग भाषा में दो मुख्य प्रकार के कथन होते हैं जो किसी कोड का तर्क बनाने के लिए आवश्यक होते हैं।

1. [सशर्त बयान](Statements%20and%20Functions/readme.md#conditional-statements)

सशर्त कथन मुख्यतः दो प्रकार के होते हैं:
- का
- यदि नहीं तो
- स्विच केस


2. [छोरों](Statements%20and%20Functions/readme.md#loops)

सशर्त कथन मुख्यतः तीन प्रकार के होते हैं:
- पाश के लिए
- घुमाव के दौरान
- करो - जबकि लूप (व्हाइल लूप का एक रूपांतर)
- करो - लूप तक

------------

फ़ंक्शन कथनों का एक ब्लॉक है जो एक विशिष्ट कार्य करता है। फ़ंक्शंस डेटा स्वीकार करते हैं, इसे संसाधित करते हैं, और परिणाम लौटाते हैं या इसे निष्पादित करते हैं। फ़ंक्शंस मुख्य रूप से पुन: प्रयोज्य की अवधारणा का समर्थन करने के लिए लिखे गए हैं। एक बार जब कोई फ़ंक्शन लिखा जाता है, तो उसे उसी कोड को दोहराए बिना आसानी से कॉल किया जा सकता है।

विभिन्न कार्यात्मक भाषाएँ फ़ंक्शन लिखने के लिए विभिन्न वाक्यविन्यास का उपयोग करती हैं।

फ़ंक्शंस के बारे में और पढ़ें [here](Statements%20and%20Functions/readme.md#functions)


## [डेटा संरचनाएं](Data%20Structures/readme.md)
कंप्यूटर विज्ञान में, डेटा संरचना एक डेटा संगठन, प्रबंधन और भंडारण प्रारूप है जो कुशल पहुंच और संशोधन को सक्षम बनाता है। अधिक सटीक रूप से, एक डेटा संरचना डेटा मानों, उनके बीच संबंधों और उन कार्यों या संचालन का एक संग्रह है जिन्हें डेटा पर लागू किया जा सकता है।

### डेटा संरचनाओं के प्रकार
- [ऐरे](Data%20Structures/readme.md#array)
- [लिंक्ड सूची](Data%20Structures/readme.md#linkedlist)
- [स्टैक](Data%20Structures/readme.md#stack)
- [कतार](Data%20Structures/readme.md#queue)
- [हैश टेबल](Data%20Structures/readme.md#hashtable)
- [हीप](Data%20Structures/readme.md#heap)
- [वृक्ष](Data%20Structures/readme.md#tree)
- [ग्राफ़](Data%20Structures/readme.md#graph)

## [एल्गोरिदम](Algorithms/readme.md)
एल्गोरिदम गणना पूरी करने के लिए आवश्यक चरणों का समूह है। हमारे उपकरण जो करते हैं उसके केंद्र में वे हैं, और यह कोई नई अवधारणा नहीं है। गणित के विकास के बाद से, हमें कार्यों को अधिक कुशलता से पूरा करने में मदद करने के लिए एल्गोरिदम की आवश्यकता रही है, लेकिन आज हम सॉर्टिंग और ग्राफ़ खोज जैसी कुछ आधुनिक कंप्यूटिंग समस्याओं पर एक नज़र डालने जा रहे हैं और दिखाएंगे कि हमने उन्हें और अधिक कैसे बनाया है कुशल ताकि आप अधिक आसानी से विंटरफ़ेल या किसी रेस्तरां या किसी चीज़ के लिए सस्ता हवाई किराया या मानचित्र दिशा-निर्देश पा सकें।

### [समय की जटिलता](Algorithms/Time%20Complexity/readme.md)
एल्गोरिदम की समय जटिलता यह अनुमान लगाती है कि एल्गोरिदम कुछ इनपुट के लिए कितना समय उपयोग करेगा। विचार दक्षता को एक फ़ंक्शन के रूप में प्रस्तुत करना है जिसका पैरामीटर इनपुट आकार है। समय जटिलता की गणना करके, हम यह निर्धारित कर सकते हैं कि एल्गोरिदम इसे लागू किए बिना पर्याप्त तेज़ है या नहीं।

### [अंतरिक्ष जटिलता](Algorithms/Space%20Complexity/readme.md)
स्पेस जटिलता एक एल्गोरिदम/प्रोग्राम द्वारा उपयोग की जाने वाली मेमोरी स्पेस की कुल मात्रा को संदर्भित करती है, जिसमें निष्पादन के लिए इनपुट मानों का स्थान भी शामिल है। स्थान की जटिलता निर्धारित करने के लिए एल्गोरिदम/प्रोग्राम में चरों द्वारा घेरे गए स्थान की गणना करें।

### [छंटाई](Algorithms/Sorting/readme.md)
सॉर्टिंग वस्तुओं की सूची को एक विशेष क्रम में व्यवस्थित करने की प्रक्रिया है। उदाहरण के लिए, यदि आपके पास नामों की सूची है, तो हो सकता है कि आप उन्हें वर्णानुक्रम में क्रमबद्ध करना चाहें। वैकल्पिक रूप से, यदि आपके पास संख्याओं की एक सूची है, तो आप उन्हें सबसे छोटे से सबसे बड़े क्रम में रखना चाहेंगे। क्रमबद्ध करना एक सामान्य कार्य है, और इसे हम कई अलग-अलग तरीकों से कर सकते हैं।

### [खोज कर](Algorithms/Searching/readme.md)
खोज एक कंटेनर के अंदर एक निश्चित लक्ष्य तत्व को खोजने के लिए एक एल्गोरिदम है। खोज एल्गोरिदम को किसी तत्व की जांच करने या किसी भी डेटा संरचना से एक तत्व पुनर्प्राप्त करने के लिए डिज़ाइन किया गया है जहां यह संग्रहीत है।


### [रेखाचित्र खोज](Algorithms/Graph/readme.md)
ग्राफ़ खोज किसी विशेष नोड को खोजने के लिए ग्राफ़ के माध्यम से खोज करने की प्रक्रिया है। ग्राफ़ एक डेटा संरचना है जिसमें शीर्षों या नोड्स या बिंदुओं का एक परिमित (और संभवतः परिवर्तनशील) सेट होता है, साथ में एक अप्रत्यक्ष ग्राफ़ के लिए इन शीर्षों के अनियंत्रित जोड़े का एक सेट या एक निर्देशित ग्राफ़ के लिए आदेशित जोड़े का एक सेट होता है। इन जोड़ियों को अप्रत्यक्ष ग्राफ़ के लिए किनारों, चापों या रेखाओं के रूप में जाना जाता है, और निर्देशित ग्राफ़ के लिए तीर, निर्देशित किनारों, निर्देशित चापों या निर्देशित रेखाओं के रूप में जाना जाता है। शीर्ष ग्राफ़ संरचना का हिस्सा हो सकते हैं या पूर्णांक सूचकांकों या संदर्भों द्वारा दर्शाई गई बाहरी इकाइयाँ हो सकते हैं। वास्तविक दुनिया के कई अनुप्रयोगों के लिए ग्राफ़ सबसे उपयोगी डेटा संरचनाओं में से एक हैं। ग्राफ़ का उपयोग वस्तुओं के बीच जोड़ीवार संबंधों को मॉडल करने के लिए किया जाता है। उदाहरण के लिए, एयरलाइन मार्ग नेटवर्क एक ग्राफ़ है जिसमें शहर शीर्ष हैं, और उड़ान मार्ग किनारे हैं। ग्राफ़ का उपयोग नेटवर्क को दर्शाने के लिए भी किया जाता है। इंटरनेट को एक ग्राफ़ के रूप में तैयार किया जा सकता है जिसमें कंप्यूटर शीर्ष हैं, और कंप्यूटर के बीच के लिंक किनारे हैं। लिंक्डइन और फेसबुक जैसे सोशल नेटवर्क पर भी ग्राफ़ का उपयोग किया जाता है। ग्राफ़ का उपयोग वास्तविक दुनिया के कई अनुप्रयोगों को दर्शाने के लिए किया जाता है: कंप्यूटर नेटवर्क, सर्किट डिज़ाइन, और वैमानिकी शेड्यूलिंग, बस कुछ ही नाम हैं।



### [गतिशील प्रोग्रामिंग](Algorithms/Dynamic%20Programming/README.md)
डायनेमिक प्रोग्रामिंग एक गणितीय अनुकूलन विधि और एक कंप्यूटर प्रोग्रामिंग विधि दोनों है। रिचर्ड बेलमैन ने 1950 के दशक में इस पद्धति को विकसित किया और एयरोस्पेस इंजीनियरिंग से लेकर अर्थशास्त्र तक कई क्षेत्रों में इसका अनुप्रयोग पाया। दोनों संदर्भों में, यह एक जटिल समस्या को पुनरावर्ती तरीके से सरल उप-समस्याओं में तोड़कर सरल बनाने को संदर्भित करता है। हालाँकि कुछ निर्णय समस्याओं को इस तरह से अलग नहीं किया जा सकता है, समय में कई बिंदुओं पर फैले निर्णय अक्सर पुनरावर्ती रूप से अलग हो जाते हैं। इसी तरह, कंप्यूटर विज्ञान में, यदि किसी समस्या को उप-समस्याओं में तोड़कर और फिर उप-समस्याओं का पुनरावर्ती रूप से इष्टतम समाधान ढूंढकर इष्टतम ढंग से हल किया जा सकता है, तो इसे एक इष्टतम उपसंरचना कहा जाता है। डायनेमिक प्रोग्रामिंग इन गुणों के साथ समस्याओं को हल करने का एक तरीका है। किसी जटिल समस्या को सरल उप-समस्याओं में तोड़ने की प्रक्रिया को "फूट डालो और राज करो" कहा जाता है।



### [लालची एल्गोरिदम](Algorithms/Greedy%20Algorithm/readme.md)
लालची एल्गोरिदम एल्गोरिदम का एक सरल, सहज वर्ग है जिसका उपयोग कुछ अनुकूलन समस्याओं का इष्टतम समाधान खोजने के लिए किया जा सकता है। उन्हें लालची कहा जाता है क्योंकि, प्रत्येक कदम पर, वे वही विकल्प चुनते हैं जो उस समय सबसे अच्छा लगता है। इसका मतलब यह है कि लालची एल्गोरिदम विश्व स्तर पर इष्टतम समाधान लौटाने की गारंटी नहीं देते हैं, बल्कि वैश्विक इष्टतम खोजने की उम्मीद में स्थानीय रूप से इष्टतम विकल्प बनाते हैं। अनुकूलन समस्याओं के लिए लालची एल्गोरिदम का उपयोग किया जाता है। एक अनुकूलन समस्या को Greedy का उपयोग करके हल किया जा सकता है यदि समस्या में निम्नलिखित गुण हैं: हर कदम पर, हम एक विकल्प चुन सकते हैं जो इस समय सबसे अच्छा लगता है, और हमें पूरी समस्या का इष्टतम समाधान मिलता है।


### [बैक ट्रैकिंग](Algorithms/Backtracking/README.md)
बैकट्रैकिंग एक एल्गोरिथम तकनीक है जो समस्याओं को पुनरावर्ती रूप से हल करने के लिए एक समय में एक टुकड़े से एक समाधान बनाने की कोशिश करती है, उन समाधानों को हटा देती है जो किसी भी समय समस्या की बाधाओं को पूरा करने में विफल रहते हैं (समय के अनुसार, यहां, इसे संदर्भित किया जाता है) खोज वृक्ष के किसी भी स्तर तक पहुँचने तक बीता हुआ समय)।


### [शाखा और बंधन](Algorithms/Branch%20and%20Bound/README.md)
ब्रांच और बाउंड कॉम्बिनेटरियल ऑप्टिमाइज़ेशन समस्याओं को हल करने की एक सामान्य तकनीक है। यह एक व्यवस्थित गणना तकनीक है जो उम्मीदवार समाधानों को खत्म करने के लिए समस्या की संरचना का उपयोग करके उम्मीदवार समाधानों की संख्या को कम करती है जो संभवतः इष्टतम नहीं हो सकते हैं।


### [विभिन्न खोज और सॉर्टिंग एल्गोरिदम की समय जटिलता और स्थान जटिलता](Not-Added)
**समय की जटिलता**: इसे कुल समय के बजाय किसी विशेष निर्देश सेट के निष्पादित होने की अपेक्षित संख्या के रूप में परिभाषित किया गया है। चूँकि समय एक निर्भर घटना है, समय की जटिलता कुछ बाहरी कारकों जैसे प्रोसेसर की गति, प्रयुक्त कंपाइलर आदि पर भिन्न हो सकती है।

**अंतरिक्ष जटिलता**: यह प्रोग्राम द्वारा अपने निष्पादन के लिए उपयोग की गई कुल मेमोरी स्पेस है।

दोनों की गणना इनपुट आकार (एन) के फ़ंक्शन के रूप में की जाती है। किसी एल्गोरिदम की समय जटिलता को बड़े O नोटेशन में व्यक्त किया जाता है।

किसी एल्गोरिदम की दक्षता इन दो मापदंडों पर निर्भर करती है।

समय जटिलता के प्रकार:

- *सर्वोत्तम समय जटिलता*: वह इनपुट जिसके लिए एल्गोरिदम कम समय या न्यूनतम समय लेता है। सबसे अच्छे मामले में, हम एक एल्गोरिदम की निचली सीमा वाली समय जटिलता की गणना करते हैं। उदाहरण के लिए: यदि खोजा जाने वाला डेटा एक रैखिक खोज में बड़े डेटा सरणी के पहले स्थान पर मौजूद है, तो सबसे अच्छा मामला होता है।
- 
- *औसत समय जटिलता*: हम सभी यादृच्छिक इनपुट लेते हैं और सभी इनपुट के लिए गणना समय की गणना करते हैं। और फिर, हम इसे इनपुट की कुल संख्या से विभाजित करते हैं।
- 
- *सबसे खराब समय जटिलता*: उस इनपुट को परिभाषित करें जिसके लिए एल्गोरिदम को लंबा समय या अधिकतम समय लगता है। सबसे खराब स्थिति में, हम एल्गोरिदम की ऊपरी सीमा की गणना करते हैं। उदाहरण: यदि खोजा जाने वाला डेटा एक रैखिक खोज एल्गोरिदम में बड़े डेटा सरणी के अंतिम स्थान पर मौजूद है, तो सबसे खराब स्थिति होती है।

कुछ सामान्य समय जटिलताएँ हैं:

- **O(1)**: यह स्थिर समय को दर्शाता है. O(1) का आम तौर पर मतलब यह है कि इनपुट आकार की परवाह किए बिना एक एल्गोरिदम में एक स्थिर समय होगा। हैश मैप्स स्थिर समय के आदर्श उदाहरण हैं।

- **O(log n)**: यह लघुगणकीय समय को दर्शाता है। O(log n) का अर्थ संचालन के लिए प्रत्येक उदाहरण के साथ कमी करना है। बाइनरी सर्च ट्रीज़ (बीएसटी) में तत्वों की खोज लघुगणक समय का एक अच्छा उदाहरण है।

- **O(n)**: यह रैखिक समय को दर्शाता है। O(n) का अर्थ है कि प्रदर्शन सीधे इनपुट के आकार के समानुपाती होता है। सरल शब्दों में, इनपुट की संख्या और उन इनपुट को निष्पादित करने में लगने वाला समय आनुपातिक होगा। सरणियों में रैखिक खोज रैखिक समय जटिलता का एक बेहतरीन उदाहरण है।

- **O(n*n)**: यह द्विघात समय को दर्शाता है। O(n^2) का अर्थ है कि प्रदर्शन लिए गए इनपुट के वर्ग के सीधे आनुपातिक है। सरल शब्दों में, निष्पादन में लगने वाला समय लगभग इनपुट आकार का वर्ग गुना होगा। नेस्टेड लूप द्विघात समय जटिलता के आदर्श उदाहरण हैं।

- **O(n log n)**: यह बहुपद समय जटिलता को दर्शाता है। O(n log n) का अर्थ है कि प्रदर्शन O(log n) का n गुना है, (जो सबसे खराब स्थिति वाली जटिलता है)। एक अच्छा उदाहरण मर्ज सॉर्ट जैसे विभाजित और जीत एल्गोरिदम होगा। यह एल्गोरिदम पहले सेट को विभाजित करता है, जिसमें O(लॉग एन) समय लगता है, फिर सेट को जीतता है और सॉर्ट करता है, जिसमें ओ(एन) समय लगता है- इसलिए, मर्ज सॉर्ट में ओ(एन लॉग एन) समय लगता है।

| एल्गोरिथम	     |             |  समय जटिलता|	       | अंतरिक्ष जटिलता |
|   :---:        |  :---:      |  :---: 	   |   :---: 	   |   :---:          |
|  	             | सर्वोत्तम	       | औसत	   | सबसे ख़राब	     |  बहुत बुरा           |
| चयन छांटना | Ω(n^2)	     | θ(n^2)	     | O(n^2)	     | O(1)             |
| बुलबुले की तरह	 | Ω(n)	         | θ(n^2)	     | O(n^2)	     | O(1)             |
| प्रविष्टि क्रम | Ω(n)	       | θ(n^2)	     | O(n^2)	     | O(1)             |
| ढेर क्रम	     | Ω(n log(n)) | θ(n log(n)) | O(n log(n)) | O(1)             |
| त्वरित छँटाई	   | Ω(n log(n)) | θ(n log(n)) | O(n^2)	     | O(n)             |
| मर्ज सॉर्ट	   | Ω(n log(n)) | θ(n log(n)) | O(n log(n)) | O(n)             |
| बकेट सॉर्ट    | Ω(n +k)	   | θ(n +k)	   | O(n^2)	     | O(n)             |
| मूलांक क्रमबद्ध 	 | Ω(nk)	     | θ(nk)	     | O(nk)	     | O(n + k)         |
| गिनती क्रमबद्ध करें 	 | Ω(n +k)	   | θ(n +k)	   | O(n +k)	   | O(k)             |
| शैल सॉर्ट 	 | Ω(n log(n)) | θ(n log(n)) | O(n^2)	     | O(1)             |
| टिम सॉर्ट	     | Ω(n)	       | θ(n log(n)) | O(n log(n)) | O(n)             |
| वृक्ष वर्गीकरण  	 | Ω(n log(n)) | θ(n log(n)) | O(n^2)	     | O(n)             |
| घन सॉर्ट	     | Ω(n)	       | θ(n log(n)) | O(n log(n)) | O(n)             |

| एल्गोरिथम	     |             |  समय जटिलता|	     |
|   :---:        |  :---:      |  :---: 	 |   :---: 	   |  
|  	             | सर्वोत्तम       | औसत	 |  सबसे ख़राब	     |
| रैखिक खोज  | O(1)	       | O(N)	     | O(N)	       | O(1)  |
| बाइनरी खोज	 | O(1)	       | O(logN)   | O(logN)	   |



## [Alan Turing](Not-Added)
एलन ट्यूरिंग (जन्म 23 जून, 1912, लंदन, इंजी.-मृत्यु 7 जून, 1954, विल्म्सलो, चेशायर) एक अंग्रेजी गणितज्ञ और तर्कशास्त्री थे। उन्होंने कैम्ब्रिज विश्वविद्यालय और प्रिंसटन के इंस्टीट्यूट फॉर एडवांस्ड स्टडी में अध्ययन किया। 1936 के अपने मौलिक पेपर "ऑन कंप्यूटेबल नंबर्स" में उन्होंने साबित किया कि गणित में सत्य का निर्धारण करने के लिए कोई सार्वभौमिक एल्गोरिथम विधि मौजूद नहीं हो सकती है और गणित में हमेशा अनिर्णीत (अज्ञात के विपरीत) प्रस्ताव शामिल होंगे। उस पेपर में ट्यूरिंग मशीन का भी परिचय दिया गया। उनका मानना था कि कंप्यूटर अंततः मानव से अप्रभेद्य विचार करने में सक्षम होंगे और उन्होंने इस क्षमता का आकलन करने के लिए एक सरल परीक्षण (ट्यूरिंग टेस्ट देखें) का प्रस्ताव रखा। इस विषय पर उनके शोधपत्रों को कृत्रिम बुद्धिमत्ता में अनुसंधान की नींव के रूप में व्यापक रूप से स्वीकार किया जाता है। उन्होंने द्वितीय विश्व युद्ध के दौरान क्रिप्टोग्राफी में बहुमूल्य काम किया और रेडियो संचार के लिए जर्मनी द्वारा उपयोग किए जाने वाले एनिग्मा कोड को तोड़ने में महत्वपूर्ण भूमिका निभाई। युद्ध के बाद, उन्होंने मैनचेस्टर विश्वविद्यालय में पढ़ाया और उस पर काम शुरू किया जिसे अब कृत्रिम बुद्धिमत्ता के रूप में जाना जाता है। इस अभूतपूर्व कार्य के दौरान, ट्यूरिंग अपने बिस्तर पर साइनाइड जहर के कारण मृत पाए गए। उनकी मृत्यु समलैंगिक कृत्य (तब एक अपराध) के लिए उनकी गिरफ्तारी और 12 महीने की हार्मोन थेरेपी की सजा के बाद हुई।


2009 में एक सार्वजनिक अभियान के बाद, ब्रिटिश प्रधान मंत्री गॉर्डन ब्राउन ने ट्यूरिंग के साथ किए गए भयावह व्यवहार के लिए ब्रिटिश सरकार की ओर से आधिकारिक सार्वजनिक माफी मांगी। महारानी एलिजाबेथ द्वितीय ने 2013 में मरणोपरांत क्षमादान दिया। "एलन ट्यूरिंग कानून" शब्द का उपयोग अब अनौपचारिक रूप से यूनाइटेड किंगडम में 2017 के कानून को संदर्भित करने के लिए किया जाता है, जो समलैंगिक कृत्यों को गैरकानूनी घोषित करने वाले ऐतिहासिक कानून के तहत चेतावनी दिए गए या दोषी ठहराए गए पुरुषों को पूर्वव्यापी रूप से माफ कर देता है।

ट्यूरिंग के पास उनकी मूर्तियों और उनके नाम पर रखी गई कई चीज़ों की एक व्यापक विरासत है, जिसमें कंप्यूटर विज्ञान नवाचारों के लिए एक वार्षिक पुरस्कार भी शामिल है। वह बैंक ऑफ इंग्लैंड के मौजूदा £50 नोट पर दिखाई देते हैं, जो उनके जन्मदिन के अवसर पर 23 जून, 2021 को जारी किया गया था। दर्शकों द्वारा वोट किए गए 2019 बीबीसी सीरीज़ में उन्हें 20वीं सदी का सबसे महान व्यक्ति बताया गया।


## [Software Engineering](Software%20Engineering/readme.md)
सॉफ्टवेयर इंजीनियरिंग कंप्यूटर विज्ञान की वह शाखा है जो सॉफ्टवेयर अनुप्रयोगों के डिजाइन, विकास, परीक्षण और रखरखाव से संबंधित है। सॉफ्टवेयर इंजीनियर अंतिम उपयोगकर्ताओं के लिए सॉफ्टवेयर समाधान बनाने के लिए इंजीनियरिंग सिद्धांतों और प्रोग्रामिंग भाषाओं के ज्ञान को लागू करते हैं।

आइए सॉफ्टवेयर इंजीनियरिंग की विभिन्न परिभाषाओं पर नजर डालें:

- आईईईई, अपने मानक 610.12-1990 में, सॉफ्टवेयर इंजीनियरिंग को एक व्यवस्थित, अनुशासित अनुप्रयोग के रूप में परिभाषित करता है, जो सॉफ्टवेयर के विकास, संचालन और रखरखाव के लिए एक गणना योग्य दृष्टिकोण है।
- फ्रिट्ज़ बाउर ने इसे 'प्रतिष्ठान' के रूप में परिभाषित किया और मानक इंजीनियरिंग सिद्धांतों का इस्तेमाल किया। यह आपको किफायती सॉफ़्टवेयर प्राप्त करने में मदद करता है जो विश्वसनीय है और वास्तविक मशीनों पर कुशलतापूर्वक काम करता है।
- बोहेम सॉफ्टवेयर इंजीनियरिंग को 'कंप्यूटर प्रोग्रामों के रचनात्मक डिजाइन और निर्माण के लिए वैज्ञानिक ज्ञान के व्यावहारिक अनुप्रयोग' के रूप में परिभाषित करता है। इसमें उनके विकास, संचालन और रखरखाव के लिए आवश्यक संबंधित दस्तावेज भी शामिल हैं।'

### Software engineer tasks and responsibilities
सफल इंजीनियर जानते हैं कि कंप्यूटर गेम से लेकर नेटवर्क नियंत्रण प्रणाली तक सब कुछ विकसित करने के लिए सही प्रोग्रामिंग भाषाओं, प्लेटफार्मों और आर्किटेक्चर का उपयोग कैसे किया जाए। अपने सिस्टम के निर्माण के अलावा, सॉफ्टवेयर इंजीनियर अन्य इंजीनियरों द्वारा निर्मित सॉफ्टवेयर का परीक्षण, सुधार और रखरखाव भी करते हैं।

इस भूमिका में, आपके दैनिक कार्यों में निम्नलिखित शामिल हो सकते हैं:

- सॉफ्टवेयर सिस्टम को डिजाइन करना और उसका रखरखाव करना
- नए सॉफ्टवेयर प्रोग्राम का मूल्यांकन और परीक्षण करना
- गति और मापनीयता के लिए सॉफ्टवेयर का अनुकूलन
- कोड लिखना और परीक्षण करना
- ग्राहकों, इंजीनियरों, सुरक्षा विशेषज्ञों और अन्य हितधारकों के साथ परामर्श करना
- हितधारकों और आंतरिक ग्राहकों के लिए नई सुविधाएँ प्रस्तुत करना

### Phases of Software Engineering
सॉफ़्टवेयर इंजीनियरिंग प्रक्रिया में कई चरण शामिल होते हैं, जिनमें आवश्यकताएँ एकत्र करना, डिज़ाइन, कार्यान्वयन, परीक्षण और रखरखाव शामिल हैं। सॉफ्टवेयर विकास के लिए एक अनुशासित दृष्टिकोण का पालन करके, सॉफ्टवेयर इंजीनियर उच्च गुणवत्ता वाले सॉफ्टवेयर बना सकते हैं जो अपने उपयोगकर्ताओं की जरूरतों को पूरा करते हैं।

- सॉफ्टवेयर इंजीनियरिंग का पहला चरण आवश्यकताओं को एकत्रित करना है। इस चरण में, सॉफ़्टवेयर इंजीनियर सॉफ़्टवेयर की कार्यात्मक और गैर-कार्यात्मक आवश्यकताओं को निर्धारित करने के लिए क्लाइंट के साथ काम करता है। कार्यात्मक आवश्यकताएँ बताती हैं कि सॉफ़्टवेयर को क्या करना चाहिए, जबकि गैर-कार्यात्मक आवश्यकताएँ बताती हैं कि उसे यह कितनी अच्छी तरह करना चाहिए। आवश्यकताएँ एकत्र करना एक महत्वपूर्ण चरण है, क्योंकि यह संपूर्ण सॉफ़्टवेयर विकास प्रक्रिया की नींव रखता है।

- आवश्यकताएँ एकत्रित होने के बाद, अगला चरण डिज़ाइन है। इस चरण में, सॉफ्टवेयर इंजीनियर सॉफ्टवेयर की वास्तुकला और कार्यक्षमता के लिए एक विस्तृत योजना बनाता है। इस योजना में एक सॉफ़्टवेयर डिज़ाइन दस्तावेज़ शामिल है जो सॉफ़्टवेयर की संरचना, व्यवहार और अन्य प्रणालियों के साथ इंटरैक्शन को निर्दिष्ट करता है। सॉफ़्टवेयर डिज़ाइन दस्तावेज़ आवश्यक है क्योंकि यह कार्यान्वयन चरण के लिए ब्लूप्रिंट के रूप में कार्य करता है।

- कार्यान्वयन चरण वह है जहां सॉफ्टवेयर इंजीनियर सॉफ्टवेयर के लिए वास्तविक कोड बनाता है। यहीं पर डिज़ाइन दस्तावेज़ को कार्यशील सॉफ़्टवेयर में बदल दिया जाता है। कार्यान्वयन चरण में कोड लिखना, उसे संकलित करना और यह सुनिश्चित करने के लिए उसका परीक्षण करना शामिल है कि यह डिज़ाइन दस्तावेज़ में निर्दिष्ट आवश्यकताओं को पूरा करता है।

- सॉफ्टवेयर इंजीनियरिंग में परीक्षण एक महत्वपूर्ण चरण है। इस चरण में, सॉफ्टवेयर इंजीनियर यह सुनिश्चित करने के लिए जांच करता है कि सॉफ्टवेयर सही ढंग से काम करता है, विश्वसनीय है और उपयोग में आसान है। इसमें कई प्रकार के परीक्षण शामिल हैं, जिनमें यूनिट परीक्षण, एकीकरण परीक्षण और सिस्टम परीक्षण शामिल हैं। परीक्षण यह सुनिश्चित करता है कि सॉफ़्टवेयर अपेक्षा के अनुरूप आवश्यकताओं और कार्यों को पूरा करता है।

- सॉफ्टवेयर इंजीनियरिंग का अंतिम चरण रखरखाव है। इस चरण में, सॉफ़्टवेयर इंजीनियर त्रुटियों को ठीक करने, नई सुविधाएँ जोड़ने या उसके प्रदर्शन में सुधार करने के लिए सॉफ़्टवेयर में परिवर्तन करता है। रखरखाव एक सतत प्रक्रिया है जो सॉफ़्टवेयर के पूरे जीवनकाल में जारी रहती है।


### Why is Software Engineering Popular?

- कंप्यूटर विज्ञान: सॉफ्टवेयर के लिए वैज्ञानिक आधार देता है क्योंकि इलेक्ट्रिकल इंजीनियरिंग मुख्य रूप से भौतिकी पर निर्भर करती है।
- प्रबंधन विज्ञान: सॉफ्टवेयर इंजीनियरिंग श्रम-केंद्रित है और तकनीकी और प्रबंधकीय नियंत्रण की मांग करती है। इसलिए, प्रबंधन विज्ञान में इसका व्यापक रूप से उपयोग किया जाता है।
- अर्थशास्त्र: इस क्षेत्र में, सॉफ्टवेयर इंजीनियरिंग आपको संसाधनों का अनुमान लगाने और लागतों को नियंत्रित करने में मदद करती है। एक कंप्यूटिंग प्रणाली विकसित की जानी चाहिए, और दिए गए बजट के भीतर डेटा को नियमित रूप से बनाए रखा जाना चाहिए।
- सिस्टम इंजीनियरिंग: अधिकांश सॉफ्टवेयर एक बहुत बड़े सिस्टम का एक घटक है। उदाहरण के लिए, उद्योग निगरानी प्रणाली में सॉफ़्टवेयर या हवाई जहाज़ पर उड़ान सॉफ़्टवेयर। इस प्रकार की प्रणाली के अध्ययन के लिए सॉफ्टवेयर इंजीनियरिंग विधियों को लागू किया जाना चाहिए।


## [Integrated Circuits](Integrated%20Circuits/readme.md)
एक एकीकृत सर्किट या मोनोलिथिक इंटीग्रेटेड सर्किट (जिसे आईसी, चिप या माइक्रोचिप भी कहा जाता है) अर्धचालक सामग्री, आमतौर पर सिलिकॉन के एक छोटे फ्लैट टुकड़े (या "चिप") पर इलेक्ट्रॉनिक सर्किट का एक सेट है। कई छोटे MOSFETs (धातु-ऑक्साइड-अर्धचालक क्षेत्र-प्रभाव ट्रांजिस्टर) एक छोटी चिप में एकीकृत होते हैं। इसके परिणामस्वरूप ऐसे सर्किट बनते हैं जो अलग-अलग इलेक्ट्रॉनिक घटकों से निर्मित सर्किट की तुलना में छोटे, तेज़ और कम महंगे होते हैं। आईसी की बड़े पैमाने पर उत्पादन क्षमता, विश्वसनीयता और एकीकृत सर्किट डिजाइन के लिए बिल्डिंग-ब्लॉक दृष्टिकोण ने असतत ट्रांजिस्टर के स्थान पर मानकीकृत आईसी को तेजी से अपनाना सुनिश्चित किया है। आईसी का उपयोग अब लगभग सभी इलेक्ट्रॉनिक उपकरणों में किया जाता है और इसने इलेक्ट्रॉनिक्स की दुनिया में क्रांति ला दी है। कंप्यूटर, मोबाइल फोन और अन्य घरेलू उपकरण अब आधुनिक समाज की संरचना का अभिन्न अंग हैं, जो आधुनिक कंप्यूटर प्रोसेसर और माइक्रोकंट्रोलर जैसे आईसी के छोटे आकार और कम लागत के कारण संभव हुआ है।

धातु-ऑक्साइड-सिलिकॉन (एमओएस) सेमीकंडक्टर डिवाइस निर्माण में तकनीकी प्रगति द्वारा बहुत बड़े पैमाने पर एकीकरण को व्यावहारिक बनाया गया था। 1960 के दशक में अपनी उत्पत्ति के बाद से, चिप्स के आकार, गति और क्षमता में काफी प्रगति हुई है, जो तकनीकी प्रगति से प्रेरित है जो एक ही आकार के चिप्स पर अधिक से अधिक एमओएस ट्रांजिस्टर फिट करते हैं - एक आधुनिक चिप में कई अरब एमओएस ट्रांजिस्टर हो सकते हैं क्षेत्रफल मनुष्य के नाखून के बराबर है। ये प्रगति, मोटे तौर पर मूर के नियम का पालन करते हुए, आज के कंप्यूटर चिप्स को 1970 के दशक की शुरुआत के कंप्यूटर चिप्स की तुलना में लाखों गुना अधिक क्षमता और हजारों गुना अधिक गति प्रदान करती है।

अलग-अलग सर्किट की तुलना में आईसी के दो मुख्य फायदे हैं: लागत और प्रदर्शन। लागत कम है क्योंकि चिप्स, उनके सभी घटकों के साथ, एक समय में एक ट्रांजिस्टर के बजाय फोटोलिथोग्राफी द्वारा एक इकाई के रूप में मुद्रित होते हैं। इसके अलावा, पैकेज्ड आईसी अलग-अलग सर्किट की तुलना में बहुत कम सामग्री का उपयोग करते हैं। प्रदर्शन उच्च है क्योंकि आईसी के घटक तेजी से स्विच करते हैं और अपने छोटे आकार और निकटता के कारण तुलनात्मक रूप से कम बिजली की खपत करते हैं। आईसी का मुख्य नुकसान उन्हें डिजाइन करने और आवश्यक फोटोमास्क बनाने की उच्च लागत है। इस उच्च प्रारंभिक लागत का मतलब है कि आईसी केवल तभी व्यावसायिक रूप से व्यवहार्य हैं जब उच्च उत्पादन मात्रा का अनुमान हो।

### Types
आधुनिक इलेक्ट्रॉनिक घटक वितरक अक्सर एकीकृत सर्किट को आगे उप-वर्गीकृत करते हैं:

- डिजिटल आईसी को लॉजिक आईसी (जैसे माइक्रोप्रोसेसर और माइक्रोकंट्रोलर), मेमोरी चिप्स (जैसे एमओएस मेमोरी और फ्लोटिंग-गेट मेमोरी), इंटरफ़ेस आईसी (लेवल शिफ्टर्स, सीरियलाइज़र/डीसेरिएलाइज़र, आदि), पावर मैनेजमेंट आईसी और प्रोग्रामेबल के रूप में वर्गीकृत किया गया है। उपकरण।
- एनालॉग आईसी को रैखिक एकीकृत सर्किट और आरएफ सर्किट (रेडियो फ्रीक्वेंसी सर्किट) के रूप में वर्गीकृत किया गया है।
- मिश्रित-सिग्नल एकीकृत सर्किट को डेटा अधिग्रहण आईसी (ए/डी कनवर्टर्स, डी/ए कनवर्टर्स, और डिजिटल पोटेंशियोमीटर), क्लॉक/टाइमिंग आईसी, स्विच्ड कैपेसिटर (एससी) सर्किट और आरएफ सीएमओएस सर्किट के रूप में वर्गीकृत किया गया है।
- त्रि-आयामी एकीकृत सर्किट (3डी आईसी) को थ्रू-सिलिकॉन वाया (टीएसवी) आईसी और सीयू-सीयू कनेक्शन आईसी में वर्गीकृत किया गया है।


## [Object Oriented Programming](Object%20Oriented%20Programming/readme.md)
ऑब्जेक्ट ओरिएंटेड प्रोग्रामिंग एक मौलिक प्रोग्रामिंग प्रतिमान है जो ऑब्जेक्ट और डेटा की अवधारणाओं पर आधारित है।

यह कोड का मानक तरीका है जिसका पालन प्रत्येक प्रोग्रामर को कोड की बेहतर पठनीयता और पुन: प्रयोज्य के लिए करना होता है। 

### * ऑब्जेक्ट ओरिएंटेड प्रोग्रामिंग की चार बुनियादी अवधारणाएँ हैं:
- अमूर्तन
- एनकैप्सुलेशन
- विरासत
- बहुरूपता

Read more about these concepts of OOP [here](Object%20Oriented%20Programming/readme.md)

## [Functional Programming](Functional%20Programming/readme.md)

कंप्यूटर विज्ञान में, कार्यात्मक प्रोग्रामिंग एक प्रोग्रामिंग प्रतिमान है जहां कार्यों को लागू करने और रचना करके प्रोग्राम का निर्माण किया जाता है। यह एक घोषणात्मक प्रोग्रामिंग प्रतिमान है जिसमें फ़ंक्शन परिभाषाएँ अभिव्यक्ति के पेड़ हैं जो प्रोग्राम की चल रही स्थिति को अद्यतन करने वाले अनिवार्य कथनों के अनुक्रम के बजाय मूल्यों को अन्य मानों पर मैप करती हैं।

कार्यात्मक प्रोग्रामिंग में, फ़ंक्शंस को प्रथम श्रेणी के नागरिकों के रूप में माना जाता है, जिसका अर्थ है कि उन्हें नामों (स्थानीय पहचानकर्ताओं सहित) से बांधा जा सकता है, तर्क के रूप में पारित किया जा सकता है, और अन्य फ़ंक्शंस से लौटाया जा सकता है, जैसे कोई अन्य डेटा प्रकार कर सकता है। यह प्रोग्रामों को घोषणात्मक और रचनायोग्य शैली में लिखने की अनुमति देता है, जहां छोटे कार्यों को मॉड्यूलर तरीके से संयोजित किया जाता है।

कार्यात्मक प्रोग्रामिंग को कभी-कभी पूरी तरह कार्यात्मक प्रोग्रामिंग के पर्याय के रूप में माना जाता है, कार्यात्मक प्रोग्रामिंग का एक उपसमूह जो सभी कार्यों को नियतात्मक गणितीय कार्यों या शुद्ध कार्यों के रूप में मानता है। जब किसी शुद्ध फ़ंक्शन को कुछ दिए गए तर्कों के साथ कॉल किया जाता है, तो यह हमेशा एक ही परिणाम देगा, और किसी भी परिवर्तनशील स्थिति या अन्य दुष्प्रभावों से प्रभावित नहीं हो सकता है। यह अशुद्ध प्रक्रियाओं के विपरीत है, जो अनिवार्य प्रोग्रामिंग में आम है, जिसके दुष्प्रभाव हो सकते हैं (जैसे प्रोग्राम की स्थिति को संशोधित करना या उपयोगकर्ता से इनपुट लेना)। विशुद्ध रूप से कार्यात्मक प्रोग्रामिंग के समर्थकों का दावा है कि साइड इफेक्ट्स को प्रतिबंधित करके, प्रोग्राम में कम बग हो सकते हैं, डिबग और परीक्षण करना आसान हो सकता है, और औपचारिक सत्यापन प्रक्रियाओं के लिए अधिक उपयुक्त हो सकते हैं।

कार्यात्मक प्रोग्रामिंग की जड़ें अकादमिक क्षेत्र में हैं, जो लैम्ब्डा कैलकुलस से विकसित हुई है, जो केवल कार्यों पर आधारित गणना की एक औपचारिक प्रणाली है। कार्यात्मक प्रोग्रामिंग ऐतिहासिक रूप से अनिवार्य प्रोग्रामिंग की तुलना में कम लोकप्रिय रही है, लेकिन आज उद्योग और शिक्षा में कई कार्यात्मक भाषाओं का उपयोग देखा जा रहा है।

Some example of functional programming languages are:
- <a href="https://lisp-lang.org/"> Common Lisp </a>
- <a href="https://www.scheme.org/"> Scheme </a>
- <a href="https://racket-lang.org/"> Racket </a>
- <a href="https://www.erlang.org/"> Erlang </a>
- <a href="https://www.haskell.org/"> Haskell </a>
- <a href="https://fsharp.org/"> F# </a>
- <a href="https://cs.lmu.edu/~ray/notes/introml/"> ML </a> 

कार्यात्मक प्रोग्रामिंग ऐतिहासिक रूप से *लैम्ब्डा कैलकुलस* से ली गई है। लैम्ब्डा कैलकुलस कार्यों के साथ संगणना का अध्ययन करने के लिए अलोंजो चर्च द्वारा विकसित एक रूपरेखा है। इसे अक्सर "दुनिया की सबसे छोटी प्रोग्रामिंग भाषा" कहा जाता है। यह इस बात की परिभाषा प्रदान करता है कि क्या गणना योग्य है और क्या नहीं। यह अपनी कम्प्यूटेशनल क्षमता में ट्यूरिंग मशीन के बराबर है और लैम्ब्डा कैलकुलस द्वारा गणना की जाने वाली कोई भी चीज़, ट्यूरिंग मशीन द्वारा गणना की जाने वाली किसी भी चीज़ की तरह, गणना योग्य है। यह कार्यों और उनके मूल्यांकन का वर्णन करने के लिए एक सैद्धांतिक रूपरेखा प्रदान करता है।

कार्यात्मक प्रोग्रामिंग की कुछ आवश्यक अवधारणाएँ हैं:
- शुद्ध कार्य
- प्रत्यावर्तन
- संदर्भात्मक पारदर्शिता
- प्रथम श्रेणी और उच्च क्रम के कार्यों के रूप में कार्य
-परिवर्तनीय अपरिवर्तनीय हैं.

**शुद्ध कार्य**: इन कार्यों के दो मुख्य गुण हैं। सबसे पहले, वे किसी भी अन्य चीज़ की परवाह किए बिना हमेशा समान तर्कों के लिए समान आउटपुट उत्पन्न करते हैं। दूसरे, इनका कोई साइड-इफेक्ट नहीं होता. यानी वे किसी भी तर्क या स्थानीय/वैश्विक चर को संशोधित नहीं करते हैं
या इनपुट/आउटपुट स्ट्रीम। बाद वाली संपत्ति को *अपरिवर्तनीयता* कहा जाता है। शुद्ध फ़ंक्शन का एकमात्र परिणाम वह मान है जो वह लौटाता है। वे नियतिवादी हैं. कार्यात्मक प्रोग्रामिंग का उपयोग करके किए गए प्रोग्राम को डीबग करना आसान होता है क्योंकि उनका कोई साइड-इफेक्ट या छिपा हुआ I/O नहीं होता है। शुद्ध फ़ंक्शन समानांतर/समवर्ती अनुप्रयोगों को लिखना भी आसान बनाते हैं। जब इस शैली में कोड लिखा जाता है, तो एक स्मार्ट कंपाइलर कई काम कर सकता है - यह निर्देशों को समानांतर कर सकता है, आवश्यकता होने तक परिणामों का मूल्यांकन करने के लिए प्रतीक्षा कर सकता है और परिणामों को याद रख सकता है क्योंकि जब तक इनपुट नहीं बदलता है तब तक परिणाम कभी नहीं बदलते हैं। यहां पायथन में शुद्ध फ़ंक्शन का एक सरल उदाहरण दिया गया है:

```अजगर
def sum(x ,y): # sum एक फ़ंक्शन है जो x और y को तर्क के रूप में लेता है
     रिटर्न x + y # मान बदले बिना x + y लौटाता है
  ```

**प्रत्यावर्तन**: शुद्ध कार्यात्मक प्रोग्रामिंग भाषाओं में कोई "के लिए" या "जबकि" लूप नहीं हैं। पुनरावृत्ति को पुनरावर्तन के माध्यम से कार्यान्वित किया जाता है। पुनरावर्ती फ़ंक्शंस बार-बार स्वयं को तब तक कॉल करते हैं जब तक कि किसी बेस केस तक नहीं पहुंच जाता। यहां रिकर्सिस का एक सरल उदाहरण दिया गया है
सी में कार्य:

```सी
int fib(n) {
   यदि(एन <= 1)
     वापसी 1;
    अन्य
      वापसी (फाइब(एन-1) + फाइबर(एन-2));
}
 ```
**संदर्भात्मक पारदर्शिता**: कार्यात्मक कार्यक्रमों में, एक बार परिभाषित चर पूरे कार्यक्रम में अपना मूल्य नहीं बदलते हैं।
कार्यात्मक कार्यक्रमों में असाइनमेंट स्टेटमेंट नहीं होते हैं। यदि हमें कुछ मान संग्रहीत करना है, तो हम इसके स्थान पर एक नया वेरिएबल परिभाषित करते हैं। इससे दुष्प्रभावों की कोई भी संभावना समाप्त हो जाती है क्योंकि निष्पादन के किसी भी बिंदु पर किसी भी चर को उसके वास्तविक मूल्य से बदला जा सकता है। किसी भी चर की स्थिति किसी भी क्षण स्थिर रहती है। उदाहरण:
 
```बैश
x = x + 1 # इससे वेरिएबल x को निर्दिष्ट मान बदल गया
          # इसलिए, अभिव्यक्ति संदर्भात्मक रूप से पारदर्शी नहीं है
```

**Functions are first-class and can be higher order**: प्रथम श्रेणी के कार्यों को प्रथम श्रेणी के चर के रूप में माना जाता है। प्रथम श्रेणी के वेरिएबल को फ़ंक्शन में पैरामीटर के रूप में पारित किया जा सकता है, फ़ंक्शन से वापस किया जा सकता है या डेटा संरचनाओं में संग्रहीत किया जा सकता है।
         
फ़ंक्शन अनुप्रयोगों के संयोजन को एलआईएसपी फॉर्म का उपयोग करके परिभाषित किया जा सकता है जिसे कहा जाता है **funcall**, जो तर्कों के रूप में एक फ़ंक्शन और तर्कों की एक श्रृंखला लेता है और उस फ़ंक्शन को उन तर्कों पर लागू करता है:

```लिस्प
(डिफ़न फ़िल्टर (तत्वों की सूची परीक्षण)
     (शर्त ((तत्वों की शून्य सूची) शून्य)
           ((फ़नकॉल परीक्षण (कार सूची-तत्व))
             (विपक्ष (कार सूची-तत्व)
                 (फ़िल्टर (सीडीआर तत्वों की सूची)
                       परीक्षा)))
            (टी (फ़िल्टर (सीडीआर सूची-तत्व))
                        परीक्षा))))
    ```
फ़ंक्शन **फ़िल्टर** परीक्षण को सूची के पहले तत्व पर लागू करता है। यदि परीक्षण गैर-शून्य लौटाता है, तो यह सूची के सीडीआर पर लागू फ़िल्टर के परिणाम पर तत्व को सम्मिलित करता है; अन्यथा, यह केवल फ़िल्टर की गई सीडीआर लौटाता है। इस फ़ंक्शन का उपयोग विभिन्न प्रकार के फ़िल्टरिंग कार्यों को करने के लिए पैरामीटर के रूप में पारित विभिन्न विधेय के साथ किया जा सकता है:

```लिस्प
     > (फ़िल्टर '(1 3 -9 5 -2 -7 6) #'प्लसपी); सभी नकारात्मक संख्याओं को फ़िल्टर करें
```
     आउटपुट: (1 3 5 6)

```लिस्प
    > (फ़िल्टर '(1 2 3 4 5 6 7 8 9) #'evenp); सभी विषम संख्याओं को फ़िल्टर करें
```
    आउटपुट: (2 4 6 8)

    और इसी तरह।

**Variables are immutable**: कार्यात्मक प्रोग्रामिंग में, हम किसी वेरिएबल को आरंभ होने के बाद संशोधित नहीं कर सकते हैं।
हम नए वेरिएबल बना सकते हैं- लेकिन हम मौजूदा वेरिएबल को संशोधित नहीं कर सकते हैं, और यह वास्तव में प्रोग्राम के पूरे रनटाइम के दौरान स्थिति बनाए रखने में मदद करता है। एक बार जब हम एक वेरिएबल बनाते हैं और उसका मान निर्धारित करते हैं, तो हम यह जानकर पूर्ण विश्वास रख सकते हैं कि उस वेरिएबल का मान कभी नहीं बदलेगा।

## [Operating Systems](Operating%20Systems/readme.md)
एक ऑपरेटिंग सिस्टम (या संक्षेप में OS) कंप्यूटर उपयोगकर्ता और कंप्यूटर हार्डवेयर के बीच मध्यस्थ के रूप में कार्य करता है। ऑपरेटिंग सिस्टम का उद्देश्य एक ऐसा वातावरण प्रदान करना है जिसमें उपयोगकर्ता प्रोग्राम को सुविधाजनक और कुशलता से निष्पादित कर सके।
ऑपरेटिंग सिस्टम एक सॉफ्टवेयर है जो कंप्यूटर हार्डवेयर का प्रबंधन करता है। कंप्यूटर सिस्टम के सही संचालन को सुनिश्चित करने और उपयोगकर्ता प्रोग्रामों को सिस्टम के उचित संचालन में हस्तक्षेप करने से रोकने के लिए हार्डवेयर को उचित तंत्र प्रदान करना चाहिए।
इससे भी अधिक सामान्य परिभाषा यह है कि ऑपरेटिंग सिस्टम कंप्यूटर पर हर समय चलने वाला एक प्रोग्राम है (आमतौर पर इसे कर्नेल कहा जाता है), बाकी सभी एप्लिकेशन प्रोग्राम होते हैं।

ऑपरेटिंग सिस्टम को दो दृष्टिकोणों से देखा जा सकता है: संसाधन प्रबंधक और
विस्तारित मशीनें. संसाधन-प्रबंधक दृष्टिकोण में, ऑपरेटिंग सिस्टम का कार्य है
सिस्टम के विभिन्न भागों को कुशलतापूर्वक प्रबंधित करें। विस्तारित-मशीन दृश्य में,
सिस्टम का काम उपयोगकर्ताओं को ऐसे सार-संक्षेप प्रदान करना है जो अधिक उपयोगी हों-
वास्तविक मशीन की तुलना में उपयोग में सुविधाजनक। इनमें प्रक्रियाएं, पता स्थान, शामिल हैं
और फ़ाइलें.
ऑपरेटिंग सिस्टम का एक लंबा इतिहास है, जब से उन्होंने ऑपरेटर को आधुनिक मल्टीप्रोग्रामिंग सिस्टम में बदल दिया।
हाइलाइट्स में प्रारंभिक बैच सिस्टम, मल्टीप्रोग्रामिंग सिस्टम और पर्सनल कंप्यूटर सिस्टम शामिल हैं।
चूंकि ऑपरेटिंग सिस्टम हार्डवेयर के साथ निकटता से इंटरैक्ट करता है, इसलिए कुछ ज्ञान
कंप्यूटर हार्डवेयर की जानकारी उन्हें समझने के लिए उपयोगी है। कंप्यूटर का निर्माण होता है
प्रोसेसर, यादें और I/O डिवाइस। ये हिस्से बसों द्वारा जुड़े हुए हैं।
वे बुनियादी अवधारणाएँ जिन पर सभी ऑपरेटिंग सिस्टम बनाए गए हैं, प्रक्रियाएँ हैं,
मेमोरी प्रबंधन, I/O प्रबंधन, फ़ाइल सिस्टम और सुरक्षा। किसी भी ऑपरेटिंग सिस्टम का दिल सिस्टम कॉल का सेट होता है जिसे वह संभाल सकता है।
ये बताते हैं कि ऑपरेटिंग सिस्टम क्या करता है.

### Operating system as a resource manager
ऑपरेटिंग सिस्टम एक जटिल सिस्टम के सभी हिस्सों का प्रबंधन करता है। आधुनिक कंप्यूटर में प्रोसेसर, मेमोरी, टाइमर, डिस्क, चूहे,
नेटवर्क इंटरफ़ेस, प्रिंटर, और अन्य उपकरणों की एक विस्तृत विविधता।
नीचे से ऊपर के दृश्य में, ऑपरेटिंग सिस्टम का काम व्यवस्थित और नियंत्रित आवंटन प्रदान करना है
विभिन्न कार्यक्रमों के बीच प्रोसेसर, मेमोरी और I/O डिवाइस जो उन्हें चाहते हैं।
आधुनिक ऑपरेटिंग सिस्टम कई प्रोग्रामों को मेमोरी में रखने और चलाने की अनुमति देते हैं
इसके साथ ही। कल्पना करें कि यदि किसी पर तीन प्रोग्राम चल रहे हों तो क्या होगा
सभी कंप्यूटरों ने अपने आउटपुट को एक ही प्रिंटर पर एक साथ प्रिंट करने का प्रयास किया।
नतीजा पूरी तरह से अराजकता होगा. ऑपरेटिंग सिस्टम संभावित अराजकता को व्यवस्थित कर सकता है
प्रिंटर के लिए नियत सभी आउटपुट को डिस्क पर बफ़र करके।
जब एक प्रोग्राम समाप्त हो जाता है, तो ऑपरेटिंग सिस्टम कर सकता है
फिर इसके आउटपुट को उस डिस्क फ़ाइल से कॉपी करें जहां इसे प्रिंटर के लिए संग्रहीत किया गया है,
जबकि उसी समय, दूसरा प्रोग्राम अधिक आउटपुट उत्पन्न करना जारी रख सकता है,
इस तथ्य से बेखबर कि आउटपुट प्रिंटर पर नहीं जा रहा है (अभी तक)।
जब किसी कंप्यूटर (या नेटवर्क) में एक से अधिक उपयोगकर्ता हों, तो प्रबंधन की आवश्यकता होती है
और मेमोरी, I/O डिवाइस और अन्य संसाधनों को और भी अधिक सुरक्षित रखें
उपयोगकर्ता अन्यथा एक दूसरे के साथ हस्तक्षेप कर सकते हैं। इसके अलावा, उपयोगकर्ताओं को अक्सर इसकी आवश्यकता होती है
न केवल हार्डवेयर बल्कि जानकारी (फ़ाइलें, डेटाबेस आदि) भी साझा करें। संक्षेप में,
ऑपरेटिंग सिस्टम के बारे में यह दृष्टिकोण मानता है कि इसका प्राथमिक कार्य ट्रैक रखना है
कौन से प्रोग्राम किस संसाधन का उपयोग कर रहे हैं, संसाधन अनुरोधों को ध्यान में रखते हुए
उपयोग के लिए और विभिन्न कार्यक्रमों और उपयोगकर्ताओं से परस्पर विरोधी अनुरोधों में मध्यस्थता करने के लिए।

### Operating system as an extended machine
मशीन-भाषा स्तर पर अधिकांश कंप्यूटरों की वास्तुकला आदिम और अजीब है
प्रोग्राम, विशेष रूप से इनपुट/आउटपुट के लिए। इस बात को और पुख्ता करने के लिए विचार करें
आधुनिक SATA (सीरियल ATA) हार्ड डिस्क अधिकांश कंप्यूटरों पर उपयोग की जाती है। डिस्क का उपयोग करने के लिए एक प्रोग्रामर को क्या जानना होगा।
तब से, इंटरफ़ेस को कई बार संशोधित किया गया है और यह पहले की तुलना में अधिक जटिल है
2007. कोई भी समझदार प्रोग्रामर हार्डवेयर स्तर पर इस डिस्क से निपटना नहीं चाहेगा।
इसके बजाय, सॉफ़्टवेयर का एक टुकड़ा जिसे डिस्क ड्राइवर कहा जाता है, हार्डवेयर से संबंधित है और डिस्क ब्लॉक को पढ़ने और लिखने के लिए एक इंटरफ़ेस प्रदान करता है,
विवरण में जाए बिना।
ऑपरेटिंग सिस्टम में I/O डिवाइस को नियंत्रित करने के लिए कई ड्राइवर होते हैं।
लेकिन अधिकांश अनुप्रयोगों के लिए यह स्तर भी बहुत कम है। इस कारण से, सभी
ऑपरेटिंग सिस्टम डिस्क का उपयोग करने के लिए अमूर्तता की एक और परत प्रदान करते हैं: फ़ाइलें।
इस अमूर्तता का उपयोग करते हुए, प्रोग्राम हार्डवेयर कैसे काम करता है इसके अव्यवस्थित विवरण से निपटे बिना फ़ाइलें बना सकते हैं, लिख सकते हैं और पढ़ सकते हैं।
यह अमूर्तता इस सारी जटिलता को प्रबंधित करने की कुंजी है। अच्छे सार-संक्षेप
लगभग असंभव कार्य को दो प्रबंधनीय कार्यों में बदलें। पहला परिभाषित कर रहा है और
अमूर्तन को कार्यान्वित करना। दूसरा इन अमूर्तनों का उपयोग हल करने के लिए कर रहा है
समस्या हाथ में है.

### History of Operating Systems
- **First Generation (1945-55)**: द्वितीय विश्व युद्ध के युग तक बैबेज के विनाशकारी प्रयासों के बाद डिजिटल कंप्यूटर के निर्माण में बहुत कम प्रगति हासिल हुई थी। आयोवा स्टेट यूनिवर्सिटी में, प्रोफेसर जॉन अटानासॉफ़ और उनके स्नातक छात्र क्लिफ़ोर्ड बेरी ने वह बनाया जिसे आज पहले परिचालन डिजिटल कंप्यूटर के रूप में मान्यता प्राप्त है। लगभग उसी समय बर्लिन में कोनराड ज़ूस ने इलेक्ट्रोमैकेनिकल रिले का उपयोग करके Z3 कंप्यूटर का निर्माण किया। मार्क I को हार्वर्ड में हॉवर्ड एकेन द्वारा बनाया गया था, कोलोसस को इंग्लैंड के बैलेचले पार्क में वैज्ञानिकों की एक टीम द्वारा बनाया गया था, और ENIAC को 1944 में पेंसिल्वेनिया विश्वविद्यालय में विलियम मौचले और उनके डॉक्टरेट छात्र जे. प्रेस्पर एकर्ट द्वारा बनाया गया था।

- **Second Generation (1955-65)**: 1950 के दशक के मध्य में ट्रांजिस्टर के आविष्कार ने स्थिति को काफी हद तक बदल दिया। कंप्यूटर इतने भरोसेमंद हो गए कि उनका निर्माण किया जा सकता था और भुगतान करने वाले ग्राहकों को इस धारणा के साथ बेचा जा सकता था कि वे कुछ सार्थक काम करने के लिए लंबे समय तक काम करते रहेंगे। मेनफ्रेम, जैसा कि इन मशीनों को अब जाना जाता है, को विशाल, विशेष रूप से वातानुकूलित कंप्यूटर कमरों में बंद रखा जाता था, जहां उन्हें प्रबंधित करने के लिए योग्य ऑपरेटरों की टीमें होती थीं। केवल बड़े व्यवसाय, महत्वपूर्ण सरकारी संस्थाएँ या संस्थान ही कई मिलियन डॉलर का मूल्य वहन कर सकते हैं।

- **Third Generation (1965-80)**: दूसरी पीढ़ी के कंप्यूटरों की तुलना में, जो व्यक्तिगत ट्रांजिस्टर से निर्मित किए गए थे, आईबीएम 360 (छोटे पैमाने पर) आईसी (एकीकृत सर्किट) को नियोजित करने वाली पहली प्रमुख कंप्यूटर लाइन थी। परिणामस्वरूप, इसने महत्वपूर्ण मूल्य/प्रदर्शन लाभ की पेशकश की। यह तुरंत हिट हो गया और अन्य सभी बड़े निर्माताओं ने इंटरऑपरेबल कंप्यूटर के परिवार की अवधारणा को तुरंत अपना लिया। OS/360 ऑपरेटिंग सिस्टम सहित सभी सॉफ़्टवेयर को मूल डिज़ाइन के सभी मॉडलों के साथ संगत माना जाता था। इसे बड़े पैमाने पर सिस्टम पर चलना पड़ता था, जो अक्सर भारी गणना और मौसम पूर्वानुमान के लिए 7094s को प्रतिस्थापित करता था, और छोटे सिस्टम, जो अक्सर कार्ड को टेप में स्थानांतरित करने के लिए केवल 1401 को प्रतिस्थापित करते थे। कुछ बाह्य उपकरणों वाली प्रणालियों और कई बाह्य उपकरणों वाली प्रणालियों दोनों को इसके साथ अच्छी तरह से काम करने की आवश्यकता है। इसे व्यावसायिक और शैक्षणिक दोनों स्थितियों में कार्य करना था। सबसे बढ़कर, इसे इन अनेक अनुप्रयोगों में से प्रत्येक के लिए प्रभावी होना था।

- **Fourth Generation (1980-Present)**: पर्सनल कंप्यूटर युग की शुरुआत एलएसआई (बड़े पैमाने पर एकीकरण) सर्किट, सिलिकॉन के एक वर्ग सेंटीमीटर पर हजारों ट्रांजिस्टर वाले प्रोसेसर के निर्माण के साथ हुई। हालाँकि पर्सनल कंप्यूटर, जिन्हें मूल रूप से माइक्रो कंप्यूटर के रूप में जाना जाता था, पीडीपी-11 वर्ग के मिनी कंप्यूटर से वास्तुकला में महत्वपूर्ण रूप से नहीं बदले, लेकिन उनकी कीमत में काफी अंतर था।

- **Fifth Generation (1990-Present)**: जब से 1940 के दशक की कॉमिक स्ट्रिप में जासूस डिक ट्रेसी ने अपनी "टू-वे रेडियो कलाई घड़ी" से बातचीत करना शुरू किया, तब से लोग पोर्टेबल संचार गैजेट के लिए तरस रहे हैं। 1946 में, एक वास्तविक मोबाइल फोन की शुरुआत हुई, और इसका वजन लगभग 40 किलोग्राम था। पहला वास्तविक पोर्टेबल फोन 1970 के दशक में आया और लगभग एक किलोग्राम वजन के साथ अविश्वसनीय रूप से हल्का था। इसे मजाक में "ईंट" कहा जाता था। जल्द ही, हर कोई एक के लिए चिल्ला रहा था।

### Functions of an OS
- **सुविधा**: एक ओएस कंप्यूटर को उपयोग में अधिक सुविधाजनक बनाता है।
- **दक्षता**: एक ओएस कंप्यूटर सिस्टम संसाधनों को कुशलतापूर्वक उपयोग करने की अनुमति देता है।
- **विकसित करने की क्षमता**: एक ओएस का निर्माण इस तरह से किया जाना चाहिए कि सेवा में हस्तक्षेप किए बिना एक ही समय में प्रभावी विकास, परीक्षण और नए सिस्टम कार्यों की शुरूआत की अनुमति मिल सके।
- **थ्रूपुट**: एक ओएस का निर्माण किया जाना चाहिए ताकि यह अधिकतम थ्रूपुट (प्रति यूनिट समय में कार्यों की संख्या) दे सके।

### Major functionalities of an OS
- **संसाधन प्रबंधन**: जब ओएस में समानांतर एक्सेसिंग होती है, तो इसका मतलब है कि जब कई उपयोगकर्ता सिस्टम तक पहुंच रहे हैं, तो ओएस एक संसाधन प्रबंधक के रूप में काम करता है। इसकी जिम्मेदारी यूजर को हार्डवेयर मुहैया कराना है. इससे सिस्टम में लोड कम हो जाता है.
- **प्रक्रिया प्रबंधन**: इसमें प्रक्रिया को शेड्यूल करना और समाप्त करना जैसे विभिन्न कार्य शामिल हैं। OS एक समय में विभिन्न कार्यों का प्रबंधन करता है। यहां सीपीयू शेड्यूलिंग होती है इसका मतलब है कि सभी कार्य शेड्यूलिंग के लिए उपयोग किए जाने वाले कई एल्गोरिदम द्वारा किए जाएंगे।
- **भंडारण प्रबंधन**: भंडारण के प्रबंधन के लिए उपयोग किया जाने वाला फ़ाइल सिस्टम तंत्र। NIFS, CFS, CIFS, NFS आदि कुछ फ़ाइल सिस्टम हैं। सारा डेटा हार्ड डिस्क के विभिन्न ट्रैक में संग्रहीत होता है जिसे स्टोरेज मैनेजर द्वारा प्रबंधित किया जाता है। इसमें हार्ड डिस्क भी शामिल थी.
- **मेमोरी प्रबंधन**: प्राथमिक मेमोरी के प्रबंधन को संदर्भित करता है। ऑपरेटिंग सिस्टम को यह ट्रैक रखना होता है कि कितनी मेमोरी का उपयोग किया गया है और किसने किया है। इसे यह तय करना होगा कि किस प्रक्रिया को मेमोरी स्पेस की आवश्यकता है और कितनी। ओएस को मेमोरी स्पेस का आवंटन और आवंटन भी करना होता है।
- **सुरक्षा/गोपनीयता प्रबंधन**: ऑपरेटिंग सिस्टम द्वारा पासवर्ड का उपयोग करके गोपनीयता भी प्रदान की जाती है ताकि अनधिकृत एप्लिकेशन प्रोग्राम या डेटा तक न पहुंच सकें। उदाहरण के लिए, विंडोज़ डेटा तक अनधिकृत पहुंच को रोकने के लिए **_Kerberos_** प्रमाणीकरण का उपयोग करता है।

### Types of Operating Systems
- **मेनफ्रेम ओएस**:
उच्च अंत में मेनफ्रेम के लिए ऑपरेटिंग सिस्टम हैं, जो कमरे के आकार के हैं
कंप्यूटर अभी भी प्रमुख कॉर्पोरेट डेटा केंद्रों में पाए जाते हैं। ये कंप्यूटर अलग-अलग होते हैं
पर्सनल कंप्यूटर उनकी I/O क्षमता के संदर्भ में। 1000 डिस्क वाला एक मेनफ्रेम
और लाखों गीगाबाइट डेटा असामान्य नहीं है; इनके साथ एक पर्सनल कंप्यूटर
विशिष्टताएँ उसके मित्रों के लिए ईर्ष्या का विषय होंगी। मेनफ्रेम भी कुछ बना रहे हैं-
हाई-एंड वेब सर्वर, बड़े पैमाने पर इलेक्ट्रॉनिक के लिए सर्वर के रूप में वापसी की बात
वाणिज्य साइटें, और व्यवसाय-से-व्यवसाय लेनदेन के लिए सर्वर।
मेनफ्रेम के लिए ऑपरेटिंग सिस्टम काफी हद तक प्रोसेसिंग की ओर उन्मुख हैं
एक साथ कई नौकरियाँ, जिनमें से अधिकांश के लिए अत्यधिक मात्रा में I/O की आवश्यकता होती है। वे आम तौर पर
तीन प्रकार की सेवाएँ प्रदान करें: बैच, लेनदेन प्रसंस्करण, और टाइमशेयरिंग

- **सर्वर ओएस**:
एक स्तर नीचे सर्वर ऑपरेटिंग सिस्टम है। वे सर्वर पर चलते हैं, जो
या तो बहुत बड़े पर्सनल कंप्यूटर, वर्कस्टेशन, या यहां तक कि मेनफ्रेम भी हैं। वे
एक नेटवर्क पर एक साथ कई उपयोगकर्ताओं को सेवा प्रदान करना और उपयोगकर्ताओं को हार्डवेयर साझा करने की अनुमति देना
और सॉफ्टवेयर संसाधन। सर्वर प्रिंट सेवा, फ़ाइल सेवा या वेब सेवा प्रदान कर सकते हैं।
इंटरनेट प्रदाता अपने ग्राहकों को समर्थन देने के लिए कई सर्वर मशीनें चलाते हैं
, और वेबसाइटें वेब पेजों को संग्रहीत करने और आने वाले अनुरोधों को संभालने के लिए सर्वर का उपयोग करती हैं।
विशिष्ट सर्वर ऑपरेटिंग सिस्टम सोलारिस, फ्रीबीएसडी, लिनक्स और विंडोज सर्वर हैं
201x.

- **मल्टीप्रोसेसर ओएस**:
मेजर-लीग कंप्यूटिंग शक्ति प्राप्त करने का एक आम तरीका कई सीपीयू को एक ही सिस्टम में जोड़ना है।
वे कैसे जुड़े हुए हैं और क्या साझा किया गया है, इस पर निर्भर करते हुए, इन प्रणालियों को समानांतर कंप्यूटर, मल्टी-कंप्यूटर या मल्टीप्रोसेसर कहा जाता है।
उन्हें विशेष ऑपरेटिंग सिस्टम की आवश्यकता होती है, लेकिन अक्सर ये सर्वर ऑपरेटिंग सिस्टम पर भिन्नताएं होती हैं,
संचार, कनेक्टिविटी और निरंतरता के लिए विशेष सुविधाओं के साथ।

- **पर्सनल कंप्यूटर ओएस**:
अगली श्रेणी पर्सनल कंप्यूटर ऑपरेटिंग सिस्टम है। सभी आधुनिक
मल्टीप्रोग्रामिंग का समर्थन करें, अक्सर दर्जनों प्रोग्राम बूट समय पर शुरू होते हैं।
इनका काम सिंगल यूजर को अच्छा सपोर्ट प्रदान करना है। इनका व्यापक रूप से उपयोग किया जाता है
वर्ड प्रोसेसिंग, स्प्रेडशीट, गेम और इंटरनेट का उपयोग। सामान्य उदाहरण हैं
Linux, FreeBSD, Windows 7, Windows 8, और Apple का OS X. पर्सनल कंप्यूटर
ऑपरेटिंग सिस्टम इतने व्यापक रूप से ज्ञात हैं कि शायद बहुत कम परिचय की आवश्यकता है।
बहुत से लोगों को यह भी पता नहीं है कि अन्य प्रकार भी मौजूद हैं।

- **एंबेडेड ओएस**:
एंबेडेड सिस्टम कंप्यूटर पर चलते हैं जो उन उपकरणों को नियंत्रित करते हैं जिन्हें आम तौर पर कंप्यूटर नहीं माना जाता है और उपयोगकर्ता द्वारा इंस्टॉल किए गए सॉफ़्टवेयर को स्वीकार नहीं करते हैं।
विशिष्ट उदाहरण माइक्रोवेव ओवन, टीवी सेट, कार, डीवीडी रिकॉर्डर, पारंपरिक हैं
फ़ोन, और एमपी3 प्लेयर। एम्बेडेड सिस्टम को हैंडहेल्ड से अलग करने वाली मुख्य संपत्ति यह निश्चितता है कि कोई भी अविश्वसनीय सॉफ़्टवेयर उन पर कभी नहीं चलेगा।
आप अपने माइक्रोवेव ओवन में नए एप्लिकेशन-सभी सॉफ़्टवेयर डाउनलोड नहीं कर सकते
ROM में है. इसका मतलब है कि अनुप्रयोगों के बीच सुरक्षा की कोई आवश्यकता नहीं है,
डिज़ाइन को सरल बनाना. एंबेडेड लिनक्स, क्यूएनएक्स और जैसे सिस्टम
VxWorks इस डोमेन में लोकप्रिय है।

- **स्मार्ट कार्ड ओएस**:
सबसे छोटे ऑपरेटिंग सिस्टम क्रेडिट कार्ड के आकार के स्मार्ट कार्ड पर चलते हैं
सीपीयू चिप्स वाले उपकरण। उनके पास बहुत गंभीर प्रसंस्करण शक्ति और स्मृति बाधाएँ हैं।
कुछ पाठक के संपर्कों द्वारा संचालित होते हैं जिसमें वे हैं
डाला गया है, लेकिन संपर्क रहित स्मार्ट कार्ड आगमनात्मक रूप से संचालित होते हैं, जो बहुत सीमित हैं
वे क्या कर सकते हैं. कुछ केवल एक ही कार्य संभाल सकते हैं, जैसे इलेक्ट्रॉनिक भुगतान, लेकिन अन्य कई कार्य संभाल सकते हैं।
अक्सर ये मालिकाना प्रणालियाँ होती हैं।
कुछ स्मार्ट कार्ड जावा उन्मुख हैं। इसका मतलब है कि स्मार्ट पर ROM
कार्ड में जावा वर्चुअल मशीन (JVM) के लिए एक दुभाषिया होता है। जावा एप्लेट्स (छोटा)
प्रोग्राम) कार्ड में डाउनलोड किए जाते हैं और जेवीएम दुभाषिया द्वारा व्याख्या किए जाते हैं।
इनमें से कुछ कार्ड एक ही समय में कई जावा एप्लेट्स को संभाल सकते हैं, जिससे
मल्टीप्रोग्रामिंग और उन्हें शेड्यूल करने की आवश्यकता। जब दो या दो से अधिक एप्लेट एक साथ मौजूद हों तो संसाधन प्रबंधन और सुरक्षा भी एक मुद्दा बन जाती है।
इन मुद्दों को कार्ड पर मौजूद (आमतौर पर बेहद आदिम) ऑपरेटिंग सिस्टम द्वारा नियंत्रित किया जाना चाहिए।

## [Memory and Storage](Memory%20and%20Storage/readme.md)

### याद
_मेमोरी_ शब्द आपके कंप्यूटर के भीतर उस घटक को संदर्भित करता है जो अल्पकालिक डेटा एक्सेस की अनुमति देता है। आप इस घटक को DRAM या डायनेमिक रैंडम-एक्सेस मेमोरी के रूप में पहचान सकते हैं। आपका कंप्यूटर अपनी अल्पकालिक मेमोरी में संग्रहीत डेटा तक पहुंच कर कई कार्य करता है। ऐसे कार्यों के कुछ उदाहरणों में दस्तावेज़ को संपादित करना, एप्लिकेशन लोड करना और इंटरनेट ब्राउज़ करना शामिल है। आपके सिस्टम की गति और प्रदर्शन आपके कंप्यूटर पर स्थापित मेमोरी की मात्रा पर निर्भर करता है।

यदि आपके पास एक डेस्क और एक फाइलिंग कैबिनेट है, तो डेस्क आपके कंप्यूटर की मेमोरी का प्रतिनिधित्व करता है। जिन वस्तुओं को आपको तुरंत उपयोग करने की आवश्यकता होती है उन्हें आसान पहुंच के लिए आपके डेस्क पर रखा जाता है। हालाँकि, आकार की सीमाओं के कारण डेस्क पर ज़्यादा कुछ संग्रहीत नहीं किया जा सकता है।

### भंडारण
जबकि मेमोरी अल्पकालिक डेटा के स्थान को संदर्भित करती है, _स्टोरेज_ आपके कंप्यूटर के भीतर का घटक है जो आपको डेटा को दीर्घकालिक रूप से संग्रहीत और एक्सेस करने की अनुमति देता है। आमतौर पर, स्टोरेज सॉलिड-स्टेट ड्राइव या हार्ड ड्राइव के रूप में आता है। स्टोरेज में आपके एप्लिकेशन, ऑपरेटिंग सिस्टम और फ़ाइलें अनिश्चित काल तक रहती हैं। कंप्यूटर को स्टोरेज सिस्टम से जानकारी पढ़ने और लिखने की आवश्यकता होती है, इसलिए स्टोरेज की गति यह निर्धारित करती है कि आपका सिस्टम कितनी तेजी से बूट हो सकता है, लोड कर सकता है और जो आपने सहेजा है उसे एक्सेस कर सकता है।

जबकि डेस्क कंप्यूटर की मेमोरी का प्रतिनिधित्व करता है, फाइलिंग कैबिनेट आपके कंप्यूटर के स्टोरेज का प्रतिनिधित्व करता है। इसमें वे वस्तुएं हैं जिन्हें सहेजने और संग्रहीत करने की आवश्यकता है लेकिन तत्काल पहुंच के लिए इसकी आवश्यकता नहीं है। फाइलिंग कैबिनेट के आकार का मतलब है कि इसमें कई चीजें रखी जा सकती हैं।

**मेमोरी और स्टोरेज के बीच एक महत्वपूर्ण अंतर** यह है कि कंप्यूटर बंद होने पर मेमोरी साफ़ हो जाती है। दूसरी ओर, चाहे आप कितनी भी बार अपना कंप्यूटर बंद कर दें, स्टोरेज बरकरार रहता है। इसलिए, डेस्क और फाइलिंग कैबिनेट सादृश्य में, जब आप कार्यालय छोड़ेंगे तो आपके डेस्क पर छोड़ी गई कोई भी फाइल फेंक दी जाएगी। आपकी फाइलिंग कैबिनेट में सब कुछ रहेगा।

### आभासी मेमोरी
कंप्यूटर सिस्टम के केंद्र में मेमोरी होती है, वह स्थान जहां प्रोग्राम चलते हैं और डेटा संग्रहीत होता है। लेकिन क्या होता है जब आप जो प्रोग्राम चला रहे हैं और जिस डेटा के साथ आप काम कर रहे हैं वह आपके कंप्यूटर की मेमोरी की भौतिक क्षमता से अधिक हो जाता है? यहीं पर वर्चुअल मेमोरी कदम रखती है, जो आपके कंप्यूटर की मेमोरी के लिए एक स्मार्ट एक्सटेंशन के रूप में कार्य करती है और इसकी क्षमताओं को बढ़ाती है।

**Definition and Purpose of Virtual Memory:**

वर्चुअल मेमोरी एक मेमोरी प्रबंधन तकनीक है जिसे ऑपरेटिंग सिस्टम द्वारा भौतिक मेमोरी (रैम) की सीमाओं को दूर करने के लिए नियोजित किया जाता है। यह सॉफ़्टवेयर अनुप्रयोगों के लिए एक भ्रम पैदा करता है कि उनके पास कंप्यूटर पर भौतिक रूप से स्थापित मेमोरी की तुलना में बड़ी मात्रा में मेमोरी तक पहुंच है। संक्षेप में, यह प्रोग्राम को कंप्यूटर की भौतिक रैम की सीमा से परे मेमोरी स्पेस का उपयोग करने में सक्षम बनाता है।

वर्चुअल मेमोरी का प्राथमिक उद्देश्य सिस्टम की प्रतिक्रियाशीलता को बनाए रखते हुए कुशल मल्टीटास्किंग और बड़े कार्यक्रमों के निष्पादन को सक्षम करना है। यह भौतिक रैम और हार्ड ड्राइव या एसएसडी जैसे सेकेंडरी स्टोरेज डिवाइस के बीच एक सहज इंटरैक्शन बनाकर इसे प्राप्त करता है।

**How Virtual Memory Extends Available Physical Memory:**

वर्चुअल मेमोरी को एक पुल के रूप में सोचें जो आपके कंप्यूटर की रैम और उसके सेकेंडरी स्टोरेज (डिस्क ड्राइव) को जोड़ता है। जब आप कोई प्रोग्राम चलाते हैं, तो उसके कुछ हिस्से तेज़ भौतिक मेमोरी (RAM) में लोड हो जाते हैं। हालाँकि, प्रोग्राम के सभी भागों का तुरंत उपयोग नहीं किया जा सकता है।

वर्चुअल मेमोरी प्रोग्राम के उन हिस्सों को स्थानांतरित करके इस स्थिति का फायदा उठाती है जिनका सक्रिय रूप से उपयोग नहीं किया जा रहा है, उन्हें रैम से सेकेंडरी स्टोरेज में ले जाया जाता है, जिससे सक्रिय रूप से उपयोग में आने वाले हिस्सों के लिए रैम में अधिक जगह बन जाती है। यह प्रक्रिया उपयोगकर्ता और चल रहे प्रोग्रामों के लिए पारदर्शी है। जब स्थानांतरित हिस्सों की फिर से आवश्यकता होती है, तो उन्हें वापस रैम में बदल दिया जाता है, जबकि अन्य कम सक्रिय हिस्सों को सेकेंडरी स्टोरेज में ले जाया जा सकता है।

भौतिक मेमोरी के अंदर और बाहर डेटा की इस गतिशील अदला-बदली को ऑपरेटिंग सिस्टम द्वारा प्रबंधित किया जाता है। यह प्रोग्राम को चलने की अनुमति देता है, भले ही वे उपलब्ध रैम से बड़े हों, क्योंकि ऑपरेटिंग सिस्टम समझदारी से निर्णय लेता है कि इष्टतम प्रदर्शन के लिए रैम में कौन सा डेटा होना चाहिए।

संक्षेप में, वर्चुअल मेमोरी एक वर्चुअलाइजेशन परत के रूप में कार्य करती है जो रैम और सेकेंडरी स्टोरेज के बीच प्रोग्राम और डेटा के कुछ हिस्सों को अस्थायी रूप से स्थानांतरित करके उपलब्ध भौतिक मेमोरी का विस्तार करती है। यह प्रक्रिया सुनिश्चित करती है कि कंप्यूटर कुशल प्रदर्शन और प्रतिक्रियाशीलता बनाए रखते हुए बड़े कार्यों और कई कार्यक्रमों को एक साथ संभाल सकता है।

## [File System](File%20System/readme.md)
कंप्यूटिंग में, फ़ाइल सिस्टम या फ़ाइल सिस्टम (अक्सर संक्षेप में एफएस) एक विधि और डेटा संरचना है जिसे ऑपरेटिंग सिस्टम यह नियंत्रित करने के लिए उपयोग करता है कि डेटा कैसे संग्रहीत और पुनर्प्राप्त किया जाता है। फ़ाइल सिस्टम के बिना, भंडारण माध्यम में रखा गया डेटा डेटा का एक बड़ा समूह होगा जिसमें यह बताने का कोई तरीका नहीं होगा कि डेटा का एक टुकड़ा कहाँ रुका और अगला शुरू हुआ या डेटा का कोई भी टुकड़ा कहाँ स्थित था जब इसे पुनः प्राप्त करने का समय था। डेटा को टुकड़ों में अलग करके और प्रत्येक टुकड़े को एक नाम देकर, डेटा को आसानी से अलग किया जा सकता है और पहचाना जा सकता है। कागज़-आधारित डेटा प्रबंधन प्रणाली के नाम से इसका नाम लेते हुए, प्रत्येक डेटा समूह को "फ़ाइल" कहा जाता है। डेटा के समूहों और उनके नामों को प्रबंधित करने के लिए उपयोग की जाने वाली संरचना और तर्क नियमों को "फ़ाइल सिस्टम" कहा जाता है।

कई प्रकार की फ़ाइल प्रणालियाँ हैं, जिनमें से प्रत्येक में अद्वितीय संरचना और तर्क, गति, लचीलेपन, सुरक्षा, आकार और बहुत कुछ के गुण हैं। कुछ फ़ाइल सिस्टम को विशिष्ट अनुप्रयोगों के लिए उपयोग करने के लिए डिज़ाइन किया गया है। उदाहरण के लिए, ISO 9660 फ़ाइल सिस्टम विशेष रूप से ऑप्टिकल डिस्क के लिए डिज़ाइन किया गया है।

फ़ाइल सिस्टम का उपयोग विभिन्न मीडिया का उपयोग करके कई प्रकार के स्टोरेज डिवाइस पर किया जा सकता है। 2019 तक, हार्ड डिस्क ड्राइव प्रमुख स्टोरेज डिवाइस रही हैं और निकट भविष्य में भी ऐसा ही बने रहने का अनुमान है। उपयोग किए जाने वाले अन्य प्रकार के मीडिया में एसएसडी, चुंबकीय टेप और ऑप्टिकल डिस्क शामिल हैं। कुछ मामलों में, जैसे कि tmpfs के साथ, कंप्यूटर की मुख्य मेमोरी (रैंडम-एक्सेस मेमोरी, RAM) अल्पकालिक उपयोग के लिए एक अस्थायी फ़ाइल सिस्टम बनाती है।

कुछ फ़ाइल सिस्टम का उपयोग स्थानीय डेटा भंडारण उपकरणों पर किया जाता है; अन्य नेटवर्क प्रोटोकॉल के माध्यम से फ़ाइल एक्सेस प्रदान करते हैं (उदाहरण के लिए, एनएफएस, एसएमबी, या 9पी क्लाइंट)। कुछ फ़ाइल सिस्टम "वर्चुअल" हैं, जिसका अर्थ है कि आपूर्ति की गई "फ़ाइलें" (जिन्हें वर्चुअल फ़ाइलें कहा जाता है) की गणना अनुरोध पर की जाती है (जैसे कि procfs और sysfs) या बैकिंग स्टोर के रूप में उपयोग की जाने वाली एक अलग फ़ाइल सिस्टम में मैपिंग मात्र हैं। फ़ाइल सिस्टम फ़ाइलों की सामग्री और उन फ़ाइलों के बारे में मेटाडेटा दोनों तक पहुंच का प्रबंधन करता है। यह भंडारण स्थान की व्यवस्था के लिए जिम्मेदार है; भौतिक भंडारण माध्यम के संबंध में विश्वसनीयता, दक्षता और ट्यूनिंग महत्वपूर्ण डिजाइन विचार हैं।

### How file systems work
एक फ़ाइल सिस्टम डेटा को संग्रहीत और व्यवस्थित करता है और इसे स्टोरेज डिवाइस में मौजूद सभी डेटा के लिए एक प्रकार के सूचकांक के रूप में सोचा जा सकता है। इन उपकरणों में हार्ड ड्राइव, ऑप्टिकल ड्राइव और फ्लैश ड्राइव शामिल हो सकते हैं।

फ़ाइल सिस्टम फ़ाइलों के नामकरण के लिए परंपराएँ निर्दिष्ट करते हैं, जिसमें एक नाम में वर्णों की अधिकतम संख्या, किन वर्णों का उपयोग किया जा सकता है, और, कुछ प्रणालियों में, फ़ाइल नाम प्रत्यय कितना लंबा हो सकता है। कई फ़ाइल सिस्टमों में, फ़ाइल नाम केस-संवेदी नहीं होते हैं।

फ़ाइल के साथ-साथ, फ़ाइल सिस्टम में मेटाडेटा में निर्देशिका में फ़ाइल का आकार और उसकी विशेषताएँ, स्थान और पदानुक्रम जैसी जानकारी होती है। मेटाडेटा ड्राइव पर उपलब्ध स्टोरेज के मुफ्त ब्लॉक और कितनी जगह उपलब्ध है, इसकी भी पहचान कर सकता है।

फ़ाइल सिस्टम में निर्देशिकाओं की संरचना के माध्यम से फ़ाइल का पथ निर्दिष्ट करने के लिए एक प्रारूप भी शामिल होता है। एक फ़ाइल को एक निर्देशिका में रखा जाता है - या विंडोज ओएस में एक फ़ोल्डर में - या पेड़ संरचना में वांछित स्थान पर उपनिर्देशिका में रखा जाता है। पीसी और मोबाइल ओएस में फ़ाइल सिस्टम होते हैं जिनमें फ़ाइलें एक पदानुक्रमित वृक्ष संरचना में रखी जाती हैं।

भंडारण माध्यम पर फ़ाइलें और निर्देशिकाएँ बनाने से पहले, विभाजन स्थापित किया जाना चाहिए। पार्टीशन हार्ड डिस्क या अन्य स्टोरेज का एक क्षेत्र है जिसे ओएस अलग से प्रबंधित करता है। एक फ़ाइल सिस्टम प्राथमिक विभाजन में समाहित होता है, और कुछ OSes एक डिस्क पर एकाधिक विभाजन की अनुमति देते हैं। इस स्थिति में, यदि एक फ़ाइल सिस्टम दूषित हो जाता है, तो दूसरे विभाजन में डेटा सुरक्षित रहेगा।

### Types of file systems
फ़ाइल सिस्टम कई प्रकार के होते हैं, सभी अलग-अलग तार्किक संरचनाओं और गुणों जैसे गति और आकार के साथ होते हैं। फ़ाइल सिस्टम का प्रकार OS और उस OS की आवश्यकताओं के अनुसार भिन्न हो सकता है। माइक्रोसॉफ्ट विंडोज, मैक ओएस एक्स और लिनक्स तीन सबसे आम पीसी ऑपरेटिंग सिस्टम हैं। मोबाइल OSes में Apple iOS और Google Android शामिल हैं।

प्रमुख फ़ाइल सिस्टम में निम्नलिखित शामिल हैं:

- फ़ाइल आवंटन तालिका (एफएटी) माइक्रोसॉफ्ट विंडोज ओएस द्वारा समर्थित है। FAT को सरल और विश्वसनीय माना जाता है और इसे लीगेसी फ़ाइल सिस्टम के अनुरूप बनाया गया है। FAT को 1977 में फ़्लॉपी डिस्क के लिए डिज़ाइन किया गया था लेकिन बाद में इसे हार्ड डिस्क के लिए अनुकूलित किया गया। अधिकांश मौजूदा ओएस के साथ कुशल और संगत होने के बावजूद, FAT अधिक आधुनिक फ़ाइल सिस्टम के प्रदर्शन और स्केलेबिलिटी से मेल नहीं खा सकता है।

- ग्लोबल फाइल सिस्टम (जीएफएस) लिनक्स ओएस के लिए एक फाइल सिस्टम है, और यह एक साझा डिस्क फाइल सिस्टम है। जीएफएस साझा ब्लॉक स्टोरेज तक सीधी पहुंच प्रदान करता है और इसे स्थानीय फ़ाइल सिस्टम के रूप में उपयोग किया जा सकता है।

- GFS2 एक अद्यतन संस्करण है जिसमें मूल GFS में शामिल सुविधाएँ नहीं हैं, जैसे अद्यतन मेटाडेटा प्रणाली। जीएनयू जनरल पब्लिक लाइसेंस शर्तों के तहत, जीएफएस और जीएफएस2 फाइल सिस्टम दोनों मुफ्त सॉफ्टवेयर के रूप में उपलब्ध हैं।

- मैक ऑपरेटिंग सिस्टम के साथ उपयोग के लिए पदानुक्रमित फ़ाइल सिस्टम (HFS) विकसित किया गया था। एचएफएस को मैक ओएस स्टैंडर्ड भी कहा जा सकता है, जो मैक ओएस एक्सटेंडेड द्वारा सफल हुआ। मूल रूप से फ़्लॉपी और हार्ड डिस्क के लिए 1985 में पेश किया गया, HFS ने मूल मैकिंटोश फ़ाइल सिस्टम को प्रतिस्थापित कर दिया। इसका उपयोग CD-ROM पर भी किया जा सकता है।

- एनटी फाइल सिस्टम - जिसे न्यू टेक्नोलॉजी फाइल सिस्टम (एनटीएफएस) के रूप में भी जाना जाता है - विंडोज एनटी 3.1 ओएस से विंडोज उत्पादों के लिए डिफ़ॉल्ट फाइल सिस्टम है। पिछले FAT फ़ाइल सिस्टम के सुधारों में बेहतर मेटाडेटा समर्थन, प्रदर्शन और डिस्क स्थान का उपयोग शामिल है। एनटीएफएस एक निःशुल्क, ओपन-सोर्स एनटीएफएस ड्राइवर के माध्यम से लिनक्स ओएस में भी समर्थित है। Mac OSes में NTFS के लिए केवल-पढ़ने के लिए समर्थन है।

- यूनिवर्सल डिस्क फॉर्मेट (यूडीएफ) ऑप्टिकल मीडिया और डीवीडी के लिए एक विक्रेता-तटस्थ फ़ाइल सिस्टम है। यूडीएफ आईएसओ 9660 फाइल सिस्टम को प्रतिस्थापित करता है और डीवीडी फोरम द्वारा चुने गए डीवीडी वीडियो और ऑडियो के लिए आधिकारिक फाइल सिस्टम है।

## [Cloud Computing](Cloud%20Computing/Readme.md)
क्लाउड कंप्यूटिंग इंटरनेट पर सूचना और एप्लिकेशन तक पहुंचने की क्षमता है। क्लाउड कंप्यूटिंग उपयोगकर्ताओं को इंटरनेट कनेक्शन के साथ किसी भी स्थान से एप्लिकेशन और डेटा तक पहुंचने की अनुमति देता है।

क्लाउड कंप्यूटिंग एक प्रकार की इंटरनेट-आधारित कंप्यूटिंग है जो मांग पर कंप्यूटर और अन्य उपकरणों को साझा कंप्यूटर प्रोसेसिंग संसाधन और डेटा प्रदान करती है।

यह कॉन्फ़िगर करने योग्य कंप्यूटिंग संसाधनों (जैसे, नेटवर्क, सर्वर, स्टोरेज, एप्लिकेशन और सेवाओं) के साझा पूल तक सर्वव्यापी, सुविधाजनक, ऑन-डिमांड नेटवर्क पहुंच को सक्षम करने के लिए एक मॉडल है जिसे न्यूनतम प्रबंधन प्रयास या सेवा के साथ तेजी से प्रावधानित और जारी किया जा सकता है। प्रदाता सहभागिता.
 
 ## Top benefits of cloud computing
 
व्यवसायों द्वारा आईटी संसाधनों के बारे में सोचने के तरीके में क्लाउड कंप्यूटिंग एक बड़ा बदलाव है। यहां सात सामान्य कारण बताए गए हैं कि संगठन क्लाउड कंप्यूटिंग सेवाओं की ओर रुख कर रहे हैं:


लागत
क्लाउड कंप्यूटिंग हार्डवेयर और सॉफ्टवेयर खरीदने और ऑन-साइट डेटा सेंटर स्थापित करने और चलाने की पूंजीगत व्यय को समाप्त कर देता है - सर्वर के रैक, बिजली और शीतलन के लिए चौबीसों घंटे बिजली, और बुनियादी ढांचे के प्रबंधन के लिए आईटी विशेषज्ञ। यह तेजी से जुड़ता है।


रफ़्तार
अधिकांश क्लाउड कंप्यूटिंग सेवाएं स्वयं-सेवा और मांग पर प्रदान की जाती हैं, इसलिए बड़ी मात्रा में कंप्यूटिंग संसाधनों को मिनटों में प्रावधानित किया जा सकता है, आमतौर पर केवल कुछ माउस क्लिक के साथ, व्यवसायों को बहुत अधिक लचीलापन मिलता है और क्षमता योजना पर दबाव कम होता है।


वैश्विक स्तर
क्लाउड कंप्यूटिंग सेवाओं के लाभों में लचीले ढंग से स्केल करने की क्षमता शामिल है। क्लाउड स्पीक में, इसका मतलब है कि आईटी संसाधनों की सही मात्रा - उदाहरण के लिए, अधिक या कम कंप्यूटिंग शक्ति, भंडारण और बैंडविड्थ - सही समय पर और सही भौगोलिक स्थान से वितरित करना।


उत्पादकता
ऑन-साइट डेटा केंद्रों को आमतौर पर बहुत सारी "रैकिंग और स्टैकिंग" की आवश्यकता होती है - हार्डवेयर सेटअप, सॉफ़्टवेयर पैचिंग, और अन्य समय लेने वाली आईटी प्रबंधन कार्य। क्लाउड कंप्यूटिंग इनमें से कई कार्यों की आवश्यकता को समाप्त कर देती है, इसलिए आईटी टीमें अधिक महत्वपूर्ण व्यावसायिक लक्ष्यों को प्राप्त करने में समय व्यतीत कर सकती हैं।


प्रदर्शन
सबसे बड़ी क्लाउड कंप्यूटिंग सेवाएँ सुरक्षित डेटा केंद्रों के विश्वव्यापी नेटवर्क पर चलती हैं, जिन्हें नियमित रूप से नवीनतम पीढ़ी के तेज़ और कुशल कंप्यूटिंग हार्डवेयर में अपग्रेड किया जाता है। यह एकल कॉर्पोरेट डेटा सेंटर पर कई लाभ प्रदान करता है, जिसमें अनुप्रयोगों के लिए कम नेटवर्क विलंबता और पैमाने की अधिक अर्थव्यवस्थाएं शामिल हैं।


विश्वसनीयता
क्लाउड कंप्यूटिंग डेटा बैकअप, डिजास्टर रिकवरी और व्यापार निरंतरता को आसान और कम खर्चीला बनाता है क्योंकि डेटा को क्लाउड प्रदाता के नेटवर्क पर कई अनावश्यक साइटों पर मिरर किया जा सकता है।


सुरक्षा
कई क्लाउड प्रदाता नीतियों, प्रौद्योगिकियों और नियंत्रणों का एक व्यापक सेट पेश करते हैं जो आपके डेटा, ऐप्स और बुनियादी ढांचे को संभावित खतरों से बचाने में मदद करते हुए आपकी सुरक्षा स्थिति को समग्र रूप से मजबूत करते हैं।

### Types of Cloud Computing Services
- [Infrastructure as a Service (IaaS)](Cloud%20Computing/Readme.md#infrastructure-as-a-service-iaas)
- [Platform as a Service (PaaS)](Cloud%20Computing/Readme.md#platform-as-a-service-paas)
- [Software as a Service (SaaS)](Cloud%20Computing/Readme.md#software-as-a-service-saas)


## [यंत्र अधिगम]()
मशीन लर्निंग कंप्यूटर को सीखना सिखाने का अभ्यास है। यह अवधारणा आने वाले डेटा पर निर्णय लेने के लिए पैटर्न पहचान के साथ-साथ भविष्य कहनेवाला एल्गोरिदम के अन्य रूपों का उपयोग करती है। यह क्षेत्र कृत्रिम बुद्धिमत्ता और कम्प्यूटेशनल सांख्यिकी से निकटता से संबंधित है।

### मशीन लर्निंग की तीन उपश्रेणियाँ हैं:

### पर्यवेक्षित मशीन लर्निंग
इसमें मशीन लर्निंग मॉडल को लेबल किए गए डेटा सेट के साथ प्रशिक्षित किया जाता है, जो मॉडल को समय के साथ अधिक सटीक रूप से सीखने और बढ़ने की अनुमति देता है। उदाहरण के लिए, एक एल्गोरिदम को कुत्तों और अन्य चीजों की तस्वीरों के साथ प्रशिक्षित किया जाएगा, जो सभी मनुष्यों द्वारा लेबल किए गए हैं, और मशीन कुत्तों की तस्वीरों को पहचानने के तरीके सीखेगी। पर्यवेक्षित मशीन लर्निंग आज सबसे आम प्रकार का उपयोग किया जाता है।

पर्यवेक्षित शिक्षण के व्यावहारिक अनुप्रयोग -
1. **जैवसूचना विज्ञान:** जैवसूचना विज्ञान इस बात का अध्ययन है कि व्यक्ति जैविक ज्ञान जैसे उंगलियों के निशान, आंखों की बनावट, कान की बालियां इत्यादि कैसे बरकरार रखते हैं। मोबाइल फोन अब इतने चतुर हो गए हैं कि वे हमारे जैविक डेटा को समझ सकते हैं और फिर सिस्टम सुरक्षा बढ़ाने के लिए हमें सत्यापित कर सकते हैं।
2. **वाक् पहचान:** यह उस प्रकार का कार्यक्रम है जहां आप अपनी आवाज कार्यक्रम तक पहुंचा सकते हैं, और यह आपकी पहचान करेगा। वास्तविक दुनिया के सबसे प्रसिद्ध गैजेट Google Assistant या Siri जैसे डिजिटल सहायक हैं, जो केवल आपकी आवाज़ से किसी शब्द का जवाब देते हैं।
3. **स्पैम का पता लगाना:** इस टूल का उपयोग काल्पनिक या मशीन-आधारित संचार को भेजे जाने से रोकने के लिए किया जाता है। जीमेल में एक एल्गोरिदम शामिल है जो कई गलत शब्दों को सीखता है। वनप्लस मैसेज ऐप उपयोगकर्ता से यह निर्दिष्ट करने के लिए कहता है कि किन शब्दों को प्रतिबंधित किया जाना चाहिए, और कीवर्ड ऐसे टेक्स्ट को ऐप से रोक देगा।
4. **दृष्टि के लिए वस्तु पहचान:** इस प्रकार के सॉफ़्टवेयर का उपयोग तब किया जाता है जब आपको कुछ भी परिभाषित करना होता है। आपके पास एक बड़ा डेटासेट है जिसका उपयोग आप एल्गोरिदम को प्रशिक्षित करने के लिए करते हैं, और यह इसका उपयोग करके एक नई वस्तु को पहचान सकता है।

### बिना पर्यवेक्षित मशीन लर्निंग
अनसुपरवाइज्ड मशीन लर्निंग में, एक प्रोग्राम बिना लेबल वाले डेटा में पैटर्न की तलाश करता है। बिना पर्यवेक्षित मशीन लर्निंग ऐसे पैटर्न या रुझान ढूंढ सकती है जिनकी लोग स्पष्ट रूप से तलाश नहीं कर रहे हैं। उदाहरण के लिए, एक अनियंत्रित मशीन लर्निंग प्रोग्राम ऑनलाइन बिक्री डेटा को देख सकता है और खरीदारी करने वाले विभिन्न प्रकार के ग्राहकों की पहचान कर सकता है।

बिना पर्यवेक्षित शिक्षण के व्यावहारिक अनुप्रयोग
1. **क्लस्टरिंग:** क्लस्टरिंग डेटा को अलग-अलग समूहों में वर्गीकृत करने की प्रक्रिया है। जब हम समूहों के बारे में सभी विवरण नहीं जानते हैं, तो हम उन्हें क्लस्टर करने के लिए अप्रशिक्षित शिक्षण का उपयोग कर सकते हैं। अनसुपरवाइज्ड लर्निंग का उपयोग उस डेटा का विश्लेषण और व्यवस्थित करने के लिए किया जाता है जिसमें पूर्व-लेबल वाले वर्ग या वर्ग गुण नहीं होते हैं। क्लस्टरिंग से कंपनियों को अपने डेटा को अधिक प्रभावी ढंग से संभालने में मदद मिल सकती है।
मान लीजिए आपके पास एक यूट्यूब चैनल है. आपके पास अपने ग्राहकों के बारे में बहुत सारी जानकारी हो सकती है। यदि आप समान ग्राहक ढूंढना चाहते हैं, तो आपको क्लस्टरिंग तकनीक का उपयोग करना होगा।
2. **विज़ुअलाइज़ेशन:** जानकारी प्रस्तुत करने के लिए आरेख, फ़ोटो, ग्राफ़, चार्ट आदि बनाने की प्रक्रिया को विज़ुअलाइज़ेशन के रूप में जाना जाता है। इस रणनीति को लागू करने के लिए अप्रशिक्षित मशीन लर्निंग का उपयोग किया जा सकता है।
मान लीजिए कि आप एक क्रिकेट कोच हैं और आपको किसी टूर्नामेंट में अपनी टीम के प्रदर्शन के बारे में जानकारी है। हो सकता है कि आप मैच के सभी आँकड़े शीघ्रता से ढूँढ़ना चाहें। आप बिना लेबल वाले और जटिल डेटा को विज़ुअलाइज़ेशन एल्गोरिदम में पास कर सकते हैं।
3. **विसंगति का पता लगाना:** विसंगति का पता लगाना असामान्य चीजों, घटनाओं या टिप्पणियों की खोज है जो नियमित डेटा से बहुत अधिक विचलन करके संदेह पैदा करते हैं। इस स्थिति में, सिस्टम को बड़ी संख्या में विशिष्ट मामलों के साथ प्रोग्राम किया जाता है। परिणामस्वरूप, जब यह किसी अप्रत्याशित घटना का पता लगाता है, तो यह निर्धारित कर सकता है कि यह एक विसंगति है या नहीं।
क्रेडिट कार्ड धोखाधड़ी का पता लगाना इसका एक अच्छा उदाहरण है। इस समस्या को अब अप्रशिक्षित मशीन लर्निंग विसंगति का पता लगाने के तरीकों का उपयोग करके संबोधित किया जा रहा है। धोखाधड़ी से बचने के लिए, सिस्टम अप्रत्याशित क्रेडिट कार्ड लेनदेन की पहचान करता है।

### अर्ध-पर्यवेक्षित मशीन लर्निंग
पर्यवेक्षित शिक्षण का नुकसान यह है कि इसमें एमएल विशेषज्ञों या डेटा वैज्ञानिकों द्वारा हाथ से लेबलिंग की आवश्यकता होती है और प्रक्रिया के लिए उच्च लागत की आवश्यकता होती है। बिना पर्यवेक्षित शिक्षण के अनुप्रयोगों का दायरा भी सीमित है। पर्यवेक्षित शिक्षण और अप्रशिक्षित शिक्षण एल्गोरिदम की इन कमियों को दूर करने के लिए, अर्ध-पर्यवेक्षित शिक्षण की अवधारणा पेश की गई है। आमतौर पर, इस संयोजन में बहुत कम मात्रा में लेबल किया गया डेटा और बड़ी मात्रा में बिना लेबल वाला डेटा होता है। इसमें शामिल मूल प्रक्रिया यह है कि सबसे पहले, प्रोग्रामर एक अनसुपरवाइज्ड लर्निंग एल्गोरिदम का उपयोग करके समान डेटा को क्लस्टर करेगा और फिर बाकी अनलेबल किए गए डेटा को लेबल करने के लिए मौजूदा लेबल किए गए डेटा का उपयोग करेगा।

अर्ध-पर्यवेक्षित शिक्षण के व्यावहारिक अनुप्रयोग -
1. **भाषण विश्लेषण:** चूंकि ऑडियो फ़ाइलों को लेबल करना एक बहुत ही गहन कार्य है, इस समस्या को हल करने के लिए अर्ध-पर्यवेक्षित शिक्षण एक बहुत ही स्वाभाविक दृष्टिकोण है।
2. **इंटरनेट सामग्री:** वर्गीकरण: प्रत्येक वेबपेज को लेबल करना एक अव्यवहारिक और अक्षम्य प्रक्रिया है और इस प्रकार अर्ध-पर्यवेक्षित शिक्षण एल्गोरिदम का उपयोग किया जाता है। यहां तक कि Google खोज एल्गोरिदम किसी दिए गए प्रश्न के लिए वेबपेज की प्रासंगिकता को रैंक करने के लिए अर्ध-पर्यवेक्षित शिक्षण के एक प्रकार का उपयोग करता है।
3. **प्रोटीन अनुक्रम वर्गीकरण:** चूंकि डीएनए स्ट्रैंड आमतौर पर बहुत बड़े होते हैं, इस क्षेत्र में अर्ध-पर्यवेक्षित शिक्षण का उदय आसन्न रहा है।

### सुदृढीकरण मशीन लर्निंग
यह पुरस्कार प्रणाली स्थापित करके सर्वोत्तम कार्रवाई करने के लिए परीक्षण और त्रुटि के माध्यम से मशीनों को प्रशिक्षित करता है। सुदृढीकरण सीखने से मॉडलों को गेम खेलने के लिए प्रशिक्षित किया जा सकता है या मशीन को यह बताकर स्वायत्त वाहनों को चलाने के लिए प्रशिक्षित किया जा सकता है कि उसने कब सही निर्णय लिया, जिससे उसे समय के साथ यह सीखने में मदद मिलती है कि उसे क्या कार्रवाई करनी चाहिए।

सुदृढीकरण सीखने के व्यावहारिक अनुप्रयोग -
1. **उत्पादन प्रणाली**
    जैसे गूगल क्लाउड ऑटोएमएल, फेसबुक होराइजन, अनुशंसा, विज्ञापन, खोज
2. **स्वायत्त ड्राइविंग**
3. **व्यवसाय प्रबंधन**
    जैसे वाहन रूटिंग समस्या का समाधान, ई-कॉमर्स में कपटपूर्ण व्यवहार, ग्राहक बातचीत से समवर्ती सुदृढीकरण सीखना
4. **अनुशंसा प्रणाली**
    जैसे खोज, अनुशंसा और ऑनलाइन विज्ञापन के लिए
   
### मशीन लर्निंग कई अन्य कृत्रिम बुद्धिमत्ता उपक्षेत्रों से भी जुड़ी है:

### प्राकृतिक भाषा प्रसंस्करण

प्राकृतिक भाषा प्रसंस्करण मशीन सीखने का एक क्षेत्र है जिसमें मशीनें कंप्यूटर को प्रोग्राम करने के लिए सामान्य रूप से उपयोग किए जाने वाले डेटा और संख्याओं के बजाय मनुष्यों द्वारा बोली और लिखी गई प्राकृतिक भाषा को समझना सीखती हैं। यह मशीनों को भाषा को पहचानने, समझने और उस पर प्रतिक्रिया देने के साथ-साथ नए पाठ बनाने और भाषाओं के बीच अनुवाद करने की अनुमति देता है। प्राकृतिक भाषा प्रसंस्करण चैटबॉट जैसी परिचित तकनीक और सिरी या एलेक्सा जैसे डिजिटल सहायकों को सक्षम बनाता है।

एनएलपी के व्यावहारिक अनुप्रयोग:
1. **प्रश्न उत्तर:** प्रश्न उत्तर उन प्रणालियों के निर्माण पर केंद्रित है जो प्राकृतिक भाषा में मनुष्यों द्वारा पूछे गए प्रश्नों का स्वचालित रूप से उत्तर देती हैं।
2. **स्पैम डिटेक्शन:** स्पैम डिटेक्शन का उपयोग उपयोगकर्ता के इनबॉक्स में आने वाले अवांछित ई-मेल का पता लगाने के लिए किया जाता है।
3. **भावना विश्लेषण:** भावना विश्लेषण को ओपिनियन माइनिंग के रूप में भी जाना जाता है। इसका उपयोग वेब पर प्रेषक के दृष्टिकोण, व्यवहार और भावनात्मक स्थिति का विश्लेषण करने के लिए किया जाता है। यह एप्लिकेशन एनएलपी (प्राकृतिक भाषा प्रसंस्करण) और आंकड़ों के संयोजन के माध्यम से पाठ (सकारात्मक, नकारात्मक, या प्राकृतिक) को मान निर्दिष्ट करके और संदर्भ के मूड (खुशी, उदास, गुस्सा, आदि) की पहचान करके कार्यान्वित किया जाता है।
4. **मशीन अनुवाद:** मशीनी अनुवाद का उपयोग पाठ या भाषण को एक प्राकृतिक भाषा से दूसरी प्राकृतिक भाषा में अनुवाद करने के लिए किया जाता है। जैसे गूगल अनुवाद
5. **वर्तनी सुधार:** माइक्रोसॉफ्ट कॉर्पोरेशन वर्तनी सुधार के लिए एमएस-वर्ड और पावरपॉइंट जैसे वर्ड प्रोसेसर सॉफ्टवेयर प्रदान करता है।

### तंत्रिका - तंत्र

तंत्रिका नेटवर्क आमतौर पर इस्तेमाल किया जाने वाला, मशीन लर्निंग एल्गोरिदम का विशिष्ट वर्ग है। कृत्रिम तंत्रिका नेटवर्क मानव मस्तिष्क पर आधारित होते हैं, जिसमें हजारों या लाखों प्रोसेसिंग नोड आपस में जुड़े होते हैं और परतों में व्यवस्थित होते हैं।

एक कृत्रिम तंत्रिका नेटवर्क में, कोशिकाएं या नोड्स जुड़े होते हैं, प्रत्येक कोशिका इनपुट को संसाधित करती है और एक आउटपुट उत्पन्न करती है जिसे अन्य न्यूरॉन्स को भेजा जाता है। लेबल किया गया डेटा नोड्स या कोशिकाओं के माध्यम से चलता है, प्रत्येक कोशिका एक अलग कार्य करती है। किसी चित्र में बिल्ली है या नहीं, इसकी पहचान करने के लिए प्रशिक्षित तंत्रिका नेटवर्क में, विभिन्न नोड्स जानकारी का आकलन करेंगे और एक आउटपुट पर पहुंचेंगे जो इंगित करेगा कि चित्र में बिल्ली है या नहीं।

तंत्रिका नेटवर्क के व्यावहारिक अनुप्रयोग:
1. **स्टॉक मार्केट भविष्यवाणी:** वास्तविक समय में एक सफल स्टॉक भविष्यवाणी करने के लिए, एक मल्टीलेयर परसेप्ट्रॉन एमएलपी (फीडफॉरवर्ड आर्टिफिशियल इंटेलिजेंस एल्गोरिदम का वर्ग) नियोजित किया जाता है। एमएलपी में नोड्स की कई परतें शामिल हैं, और इनमें से प्रत्येक परत अगले नोड्स से पूरी तरह से जुड़ी हुई है। एमएलपी मॉडल के निर्माण के लिए स्टॉक के पिछले प्रदर्शन, वार्षिक रिटर्न और गैर-लाभकारी अनुपात पर विचार किया जाता है।
2. **सोशल मीडिया:** बहुस्तरीय परसेप्ट्रॉन सोशल मीडिया रुझानों का पूर्वानुमान लगाते हैं। यह विभिन्न प्रशिक्षण विधियों जैसे मीन एब्सोल्यूट एरर (एमएई), रूट मीन स्क्वेयर्ड एरर (आरएमएसई), और मीन स्क्वेयर्ड एरर (एमएसई) का उपयोग करता है। एमएलपी उपयोगकर्ता के पसंदीदा इंस्टाग्राम पेज, बुकमार्क किए गए विकल्प आदि जैसे कई कारकों को ध्यान में रखता है। सोशल मीडिया नेटवर्क के माध्यम से व्यक्तियों के व्यवहार के विश्लेषण के बाद, डेटा को लोगों की खर्च करने की आदतों से जोड़ा जा सकता है। एमएलपी एएनएन का उपयोग सोशल मीडिया अनुप्रयोगों से डेटा निकालने के लिए किया जाता है।
3. **एयरोस्पेस:** एयरोस्पेस इंजीनियरिंग एक विस्तृत शब्द है जो अंतरिक्ष यान और विमान में विकास को कवर करता है। दोष निदान, उच्च-प्रदर्शन ऑटो-पायलटिंग, विमान नियंत्रण प्रणालियों को सुरक्षित करना, और कुंजी गतिशील सिमुलेशन मॉडलिंग करना कुछ प्रमुख क्षेत्र हैं जिन पर तंत्रिका नेटवर्क ने कब्जा कर लिया है। समय विलंब तंत्रिका नेटवर्क को गैर-रेखीय समय गतिशील प्रणालियों के मॉडलिंग के लिए नियोजित किया जा सकता है।

### ध्यान लगा के पढ़ना या सीखना

डीप लर्निंग नेटवर्क कई परतों वाले तंत्रिका नेटवर्क हैं। स्तरित नेटवर्क व्यापक मात्रा में डेटा संसाधित कर सकता है और नेटवर्क में प्रत्येक लिंक का "वजन" निर्धारित कर सकता है - उदाहरण के लिए, एक छवि पहचान प्रणाली में, तंत्रिका नेटवर्क की कुछ परतें चेहरे की व्यक्तिगत विशेषताओं, जैसे आंखें, नाक, का पता लगा सकती हैं। या मुंह, जबकि एक अन्य परत यह बताने में सक्षम होगी कि क्या वे विशेषताएं इस तरह से दिखाई देती हैं जो चेहरे को इंगित करती हैं।

गहन शिक्षण के व्यावहारिक अनुप्रयोग:
1. **स्वचालित पाठ निर्माण -** पाठ का संग्रह सीखा जाता है, और इस मॉडल से, नया पाठ उत्पन्न होता है, शब्द-दर-शब्द या चरित्र-दर-चरित्र। फिर यह मॉडल वर्तनी, विराम चिह्न और वाक्य बनाना सीखने में सक्षम है, या यह शैली को भी पकड़ सकता है।
2. **स्वास्थ्य देखभाल-** विभिन्न बीमारियों के निदान और उनके इलाज में मदद करता है।
3. **स्वचालित मशीन अनुवाद -** एक भाषा के कुछ शब्दों, वाक्यों या वाक्यांशों को दूसरी भाषा में बदल दिया जाता है (डीप लर्निंग पाठ और छवियों के क्षेत्र में शीर्ष परिणाम प्राप्त कर रहा है)।
4. **छवि पहचान -** छवियों में लोगों और वस्तुओं को पहचानता है और साथ ही सामग्री और संदर्भ को समझता है। इस क्षेत्र का उपयोग गेमिंग, रिटेल, पर्यटन आदि में पहले से ही किया जा रहा है।
5. **भूकंप की भविष्यवाणी करना -** एक कंप्यूटर को विस्कोइलास्टिक गणना करना सिखाता है, जिसका उपयोग भूकंप की भविष्यवाणी करने में किया जाता है।

## [Web Technology](Web%20Technology/WebTechnology.md#web-tecnology)
वेब प्रौद्योगिकी उन विभिन्न उपकरणों और तकनीकों को संदर्भित करती है जिनका उपयोग इंटरनेट पर विभिन्न प्रकार के उपकरणों के बीच संचार की प्रक्रिया में किया जाता है। वेब पेजों तक पहुँचने के लिए वेब ब्राउज़र का उपयोग किया जाता है। वेब ब्राउज़र को ऐसे प्रोग्राम के रूप में परिभाषित किया जा सकता है जो इंटरनेट पर टेक्स्ट, डेटा, चित्र, एनीमेशन और वीडियो प्रदर्शित करते हैं। वर्ल्ड वाइड वेब पर हाइपरलिंक किए गए संसाधनों तक वेब ब्राउज़र द्वारा प्रदान किए गए सॉफ़्टवेयर इंटरफ़ेस का उपयोग करके पहुंचा जा सकता है।
### वेब प्रौद्योगिकी को निम्नलिखित वर्गों में वर्गीकृत किया जा सकता है:
- वर्ल्ड वाइड वेब (डब्ल्यूडब्ल्यूडब्ल्यू)
वर्ल्ड वाइड वेब कई अलग-अलग तकनीकों पर आधारित है: वेब ब्राउज़र, हाइपरटेक्स्ट मार्कअप लैंग्वेज (HTML), और हाइपरटेक्स्ट ट्रांसफर प्रोटोकॉल (HTTP)।
- वेब ब्राउज़र
वेब ब्राउज़र www (वर्ल्ड वाइड वेब) को एक्सप्लोर करने के लिए एक एप्लिकेशन सॉफ़्टवेयर है। यह सर्वर और क्लाइंट के बीच एक इंटरफ़ेस प्रदान करता है और वेब दस्तावेज़ों और सेवाओं के लिए सर्वर से अनुरोध करता है।
- वेब सर्वर
वेब सर्वर एक प्रोग्राम है जो उपयोगकर्ताओं के नेटवर्क अनुरोधों को संसाधित करता है और उन्हें वेब पेज बनाने वाली फ़ाइलों की सेवा प्रदान करता है। यह आदान-प्रदान हाइपरटेक्स्ट ट्रांसफर प्रोटोकॉल (HTTP) का उपयोग करके होता है।
- वेब पृष्ठ
वेबपेज एक डिजिटल दस्तावेज़ है जो वर्ल्ड वाइड वेब से जुड़ा हुआ है और इंटरनेट से जुड़ा कोई भी व्यक्ति जिसके पास वेब ब्राउज़र है, देख सकता है।
- वेब विकास
वेब डेवलपमेंट से तात्पर्य वेबसाइटों के निर्माण, निर्माण और रखरखाव से है। इसमें वेब डिज़ाइन, वेब प्रकाशन, वेब प्रोग्रामिंग और डेटाबेस प्रबंधन जैसे पहलू शामिल हैं। यह एक एप्लिकेशन का निर्माण है जो इंटरनेट यानी वेबसाइटों पर काम करता है।
### वेब विकास को दो प्रकार से वर्गीकृत किया जा सकता है:
### फ्रंटएंड डेवलपमेंट
किसी वेबसाइट का वह भाग जहां उपयोगकर्ता सीधे इंटरैक्ट करता है उसे फ्रंट एंड कहा जाता है। इसे एप्लिकेशन का 'ग्राहक पक्ष' भी कहा जाता है।
### बैकएंड विकास
बैकएंड किसी वेबसाइट का सर्वर साइड होता है। यह वेबसाइट का वह हिस्सा है जिसे उपयोगकर्ता देख और इंटरैक्ट नहीं कर सकते। यह सॉफ़्टवेयर का वह भाग है जो उपयोगकर्ताओं के सीधे संपर्क में नहीं आता है। इसका उपयोग डेटा को स्टोर करने और व्यवस्थित करने के लिए किया जाता है।


# [Networking](Networking/readme.md#networking)
कंप्यूटर नेटवर्क नेटवर्क नोड्स पर स्थित या उनके द्वारा प्रदान किए गए संसाधनों को साझा करने वाले कंप्यूटरों का एक समूह है। कंप्यूटर एक दूसरे के साथ संचार करने के लिए डिजिटल इंटरकनेक्शन पर सामान्य संचार प्रोटोकॉल का उपयोग करते हैं। ये इंटरकनेक्शन भौतिक रूप से वायर्ड, ऑप्टिकल और वायरलेस रेडियो-फ़्रीक्वेंसी विधियों पर आधारित दूरसंचार नेटवर्क प्रौद्योगिकियों से बने होते हैं जिन्हें विभिन्न नेटवर्क टोपोलॉजी में व्यवस्थित किया जा सकता है।

कंप्यूटर नेटवर्क के नोड्स में पर्सनल कंप्यूटर, सर्वर, नेटवर्किंग हार्डवेयर, या अन्य विशिष्ट या सामान्य-उद्देश्य वाले होस्ट शामिल हो सकते हैं। वे नेटवर्क पते से पहचाने जाते हैं और उनके होस्टनाम हो सकते हैं। होस्टनाम नोड्स के लिए यादगार लेबल के रूप में काम करते हैं, प्रारंभिक असाइनमेंट के बाद शायद ही कभी बदले जाते हैं। नेटवर्क पते इंटरनेट प्रोटोकॉल जैसे संचार प्रोटोकॉल द्वारा नोड्स का पता लगाने और पहचानने का काम करते हैं।

कंप्यूटर नेटवर्क को कई मानदंडों के आधार पर वर्गीकृत किया जा सकता है, जिसमें सिग्नल, बैंडविड्थ, नेटवर्क ट्रैफ़िक को व्यवस्थित करने के लिए संचार प्रोटोकॉल, नेटवर्क आकार, टोपोलॉजी, ट्रैफ़िक नियंत्रण तंत्र और संगठनात्मक इरादे को ले जाने के लिए उपयोग किया जाने वाला ट्रांसमिशन माध्यम शामिल है।

## नेटवर्किंग के प्रकार
कंप्यूटर नेटवर्किंग के दो प्राथमिक प्रकार हैं:
- वायर्ड नेटवर्किंग: वायर्ड नेटवर्किंग के लिए नोड्स के बीच परिवहन के लिए भौतिक माध्यम के उपयोग की आवश्यकता होती है। कॉपर-आधारित ईथरनेट केबलिंग, जो अपनी कम लागत और स्थायित्व के कारण लोकप्रिय है, आमतौर पर व्यवसायों और घरों में डिजिटल संचार के लिए उपयोग की जाती है। वैकल्पिक रूप से, ऑप्टिकल फाइबर का उपयोग डेटा को अधिक दूरी पर और तेज गति से ले जाने के लिए किया जाता है, लेकिन इसमें कई समस्याएं हैं, जिनमें उच्च लागत और अधिक नाजुक घटक शामिल हैं।
- वायरलेस नेटवर्किंग: वायरलेस नेटवर्किंग हवा में डेटा परिवहन के लिए रेडियो तरंगों का उपयोग करती है, जिससे उपकरणों को बिना किसी केबल के नेटवर्क से जोड़ा जा सकता है। वायरलेस LAN वायरलेस नेटवर्किंग का सबसे प्रसिद्ध और व्यापक रूप से तैनात रूप है। विकल्पों में माइक्रोवेव, सैटेलाइट, सेल्यूलर और ब्लूटूथ आदि शामिल हैं।
## ओ एस आई मॉडल
OSI का मतलब **ओपन सिस्टम इंटरकनेक्शन** है। इसे वर्ष 1984 में ISO - '**अंतर्राष्ट्रीय मानकीकरण संगठन**' द्वारा विकसित किया गया था। यह एक 7-परत वास्तुकला है जिसमें प्रत्येक परत में प्रदर्शन करने के लिए विशिष्ट कार्यक्षमता होती है। ये सभी सात परतें दुनिया भर में डेटा को एक व्यक्ति से दूसरे व्यक्ति तक पहुंचाने के लिए सहयोगात्मक रूप से काम करती हैं।

### **1\. भौतिक परत (परत 1):**

OSI संदर्भ मॉडल की सबसे निचली परत भौतिक परत है। यह उपकरणों के बीच वास्तविक भौतिक कनेक्शन के लिए जिम्मेदार है। भौतिक परत में **बिट्स के रूप में जानकारी होती है।** यह व्यक्तिगत बिट्स को एक नोड से दूसरे नोड तक प्रसारित करने के लिए जिम्मेदार है। डेटा प्राप्त करते समय, यह परत प्राप्त सिग्नल को प्राप्त करेगी और इसे 0s और 1s में परिवर्तित करेगी और उन्हें डेटा लिंक परत पर भेजेगी, जो फ्रेम को वापस एक साथ रख देगी।

![](Networking/OSI%20Model/img/computer-network-osi-model-layers-bits.png)

भौतिक परत के कार्य इस प्रकार हैं:

1. **बिट सिंक्रोनाइजेशन:** भौतिक परत एक घड़ी प्रदान करके बिट्स का सिंक्रोनाइजेशन प्रदान करती है। यह घड़ी प्रेषक और रिसीवर दोनों को नियंत्रित करती है और इस प्रकार बिट स्तर पर सिंक्रनाइज़ेशन प्रदान करती है।
2. **बिट दर नियंत्रण:** भौतिक परत ट्रांसमिशन दर को भी परिभाषित करती है, यानी, प्रति सेकंड भेजे गए बिट्स की संख्या।
3. **भौतिक टोपोलॉजी:** भौतिक परत निर्दिष्ट करती है कि नेटवर्क में विभिन्न डिवाइस/नोड्स को कैसे व्यवस्थित किया जाता है, यानी, बस, स्टार, या जाल टोपोलॉजी।
4. **ट्रांसमिशन मोड:** भौतिक परत यह भी परिभाषित करती है कि दो कनेक्टेड डिवाइसों के बीच डेटा कैसे प्रवाहित होता है। संभावित विभिन्न ट्रांसमिशन मोड सिंप्लेक्स, हाफ-डुप्लेक्स और फुल-डुप्लेक्स हैं।

### **2\. डेटा लिंक परत (डीएलएल) (परत 2):**

डेटा लिंक परत संदेश की नोड-टू-नोड डिलीवरी के लिए जिम्मेदार है। इस परत का मुख्य कार्य यह सुनिश्चित करना है कि भौतिक परत पर एक नोड से दूसरे नोड तक डेटा स्थानांतरण त्रुटि मुक्त हो। जब कोई पैकेट नेटवर्क में आता है, तो यह डीएलएल की जिम्मेदारी है कि वह इसे अपने मैक पते का उपयोग करके होस्ट तक पहुंचाए।
डेटा लिंक परत को दो उप-परतों में विभाजित किया गया है:

1. लॉजिकल लिंक कंट्रोल (एलएलसी)
2. मीडिया एक्सेस कंट्रोल (मैक)

नेटवर्क परत से प्राप्त पैकेट को एनआईसी (नेटवर्क इंटरफेस कार्ड) के फ्रेम आकार के आधार पर फ्रेम में विभाजित किया गया है। डीएलएल हेडर में प्रेषक और रिसीवर के मैक पते को भी समाहित करता है।

रिसीवर का मैक पता तार पर एआरपी (एड्रेस रेजोल्यूशन प्रोटोकॉल) अनुरोध डालकर प्राप्त किया जाता है, जिसमें पूछा जाता है, "वह आईपी पता किसके पास है?" और गंतव्य होस्ट अपने मैक पते के साथ उत्तर देगा।  

![](Networking/OSI%20Model/img/computer-network-osi-model-layers-framing.png)

डेटा लिंक परत के कार्य हैं:

1. **फ़्रेमिंग:** फ़्रेमिंग डेटा लिंक परत का एक कार्य है। यह प्रेषक को बिट्स के एक सेट को प्रसारित करने का एक तरीका प्रदान करता है जो रिसीवर के लिए सार्थक है। इसे फ़्रेम के आरंभ और अंत में विशेष बिट पैटर्न संलग्न करके पूरा किया जा सकता है।
2. **भौतिक पता:** फ्रेम बनाने के बाद, डेटा लिंक परत प्रत्येक फ्रेम के हेडर में प्रेषक और/या रिसीवर के भौतिक पते (मैक पते) जोड़ती है।
3. **त्रुटि नियंत्रण:** डेटा लिंक परत त्रुटि नियंत्रण का तंत्र प्रदान करती है जिसमें यह क्षतिग्रस्त या खोए हुए फ़्रेमों का पता लगाता है और उन्हें पुनः प्रसारित करता है।
4. **प्रवाह नियंत्रण:** डेटा दर दोनों तरफ स्थिर होनी चाहिए, अन्यथा डेटा दूषित हो सकता है; इस प्रकार, प्रवाह नियंत्रण पावती प्राप्त करने से पहले भेजे जा सकने वाले डेटा की मात्रा का समन्वय करता है।
5. **पहुँच नियंत्रण:** जब एक एकल संचार चैनल को कई उपकरणों द्वारा साझा किया जाता है, तो डेटा लिंक परत की मैक उप-परत यह निर्धारित करने में मदद करती है कि किसी दिए गए समय में किस उपकरण का चैनल पर नियंत्रण है।

### **3\. नेटवर्क परत (परत 3):**

नेटवर्क लेयर विभिन्न नेटवर्क में स्थित एक होस्ट से दूसरे होस्ट तक डेटा के प्रसारण के लिए काम करती है। यह पैकेट रूटिंग का भी ध्यान रखता है, यानी, उपलब्ध मार्गों की संख्या से पैकेट को प्रसारित करने के लिए सबसे छोटे रास्ते का चयन। प्रेषक और प्राप्तकर्ता के आईपी पते को नेटवर्क परत द्वारा हेडर में रखा जाता है।

नेटवर्क परत के कार्य हैं:

1. **रूटिंग:** नेटवर्क लेयर प्रोटोकॉल यह निर्धारित करते हैं कि स्रोत से गंतव्य तक कौन सा मार्ग उपयुक्त है। नेटवर्क लेयर के इस कार्य को रूटिंग के रूप में जाना जाता है।
2. **लॉजिकल एड्रेसिंग:** इंटरनेटवर्क पर प्रत्येक डिवाइस को विशिष्ट रूप से पहचानने के लिए, नेटवर्क लेयर एक एड्रेसिंग स्कीम को परिभाषित करता है। प्रेषक और प्राप्तकर्ता के आईपी पते को नेटवर्क परत द्वारा हेडर में रखा जाता है। ऐसा पता प्रत्येक डिवाइस को विशिष्ट और सार्वभौमिक रूप से अलग करता है।

# [Internet](Internet/readme.md#internet)
इंटरनेट इंटरकनेक्टेड कंप्यूटर नेटवर्क की एक वैश्विक प्रणाली है जो मानक इंटरनेट प्रोटोकॉल सूट का उपयोग करती है ([TCP/IP](Networking/readme.md#tcptransmission-control-protocol)) दुनिया भर में अरबों उपयोगकर्ताओं को सेवा प्रदान करने के लिए। यह नेटवर्कों का एक नेटवर्क है जिसमें स्थानीय से वैश्विक दायरे के लाखों निजी, सार्वजनिक, शैक्षणिक, व्यावसायिक और सरकारी नेटवर्क शामिल हैं जो इलेक्ट्रॉनिक, वायरलेस और ऑप्टिकल नेटवर्किंग प्रौद्योगिकियों की एक विस्तृत श्रृंखला से जुड़े हुए हैं। इंटरनेट सूचना संसाधनों और सेवाओं की एक विस्तृत श्रृंखला प्रदान करता है, जैसे कि इंटरलिंक्ड हाइपरटेक्स्ट दस्तावेज़ और वर्ल्ड वाइड वेब के एप्लिकेशन। ([WWW](Internet/readme.md#world-wide-web-www)) और ईमेल का समर्थन करने के लिए बुनियादी ढाँचा।

## [World Wide Web (WWW)](Internet/readme.md#world-wide-web-www)
वर्ल्ड वाइड वेब (डब्ल्यूडब्ल्यूडब्ल्यू) एक सूचना स्थान है जहां दस्तावेजों और अन्य वेब संसाधनों को यूनिफ़ॉर्म रिसोर्स लोकेटर (यूआरएल) द्वारा पहचाना जाता है, हाइपरटेक्स्ट लिंक द्वारा इंटरलिंक किया जाता है और इंटरनेट के माध्यम से पहुंच योग्य होता है। अंग्रेजी वैज्ञानिक टिम बर्नर्स-ली ने 1989 में वर्ल्ड वाइड वेब का आविष्कार किया था। उन्होंने स्विट्जरलैंड में CERN में कार्यरत रहते हुए 1990 में पहला वेब ब्राउज़र लिखा था। ब्राउज़र को 1991 में CERN के बाहर, पहले जनवरी 1991 में अन्य अनुसंधान संस्थानों के लिए और अगस्त 1991 में इंटरनेट पर आम जनता के लिए जारी किया गया था।

## [Internet Protocol (IP)](Internet/readme.md#internet-protocol-ip)
इंटरनेट प्रोटोकॉल (आईपी) डेटा के पैकेटों को रूट करने और संबोधित करने के लिए एक प्रोटोकॉल या नियमों का सेट है, ताकि वे पूरे नेटवर्क में यात्रा कर सकें और सही गंतव्य पर पहुंच सकें। इंटरनेट पर मौजूद डेटा को छोटे-छोटे टुकड़ों में विभाजित किया जाता है जिन्हें पैकेट कहा जाता है।

## [डीबीएमएस]()

डेटाबेस क्या है?
-------------------

डेटाबेस संबंधित डेटा का एक संग्रह है जो वास्तविक दुनिया के कुछ पहलुओं का प्रतिनिधित्व करता है। एक डेटाबेस सिस्टम को एक निश्चित कार्य के लिए डेटा के निर्माण और पॉप्युलेट करने के लिए डिज़ाइन किया गया है।

डीबीएमएस क्या है?
-----------------

**डेटाबेस प्रबंधन प्रणाली (डीबीएमएस)** उचित सुरक्षा उपायों पर विचार करते हुए उपयोगकर्ताओं के डेटा को संग्रहीत और पुनर्प्राप्त करने के लिए सॉफ्टवेयर है। इसमें प्रोग्रामों का एक समूह होता है जो डेटाबेस में हेरफेर करता है। DBMS किसी एप्लिकेशन से डेटा के अनुरोध को स्वीकार करता है और ऑपरेटिंग सिस्टम को विशिष्ट डेटा प्रदान करने का निर्देश देता है। बड़े सिस्टम में, DBMS उपयोगकर्ताओं और अन्य तृतीय-पक्ष सॉफ़्टवेयर को डेटा संग्रहीत करने और पुनर्प्राप्त करने में सहायता करता है।

DBMS उपयोगकर्ताओं को उनकी आवश्यकताओं के अनुसार अपना डेटाबेस बनाने की अनुमति देता है। "डीबीएमएस" शब्द में डेटाबेस और अन्य एप्लिकेशन प्रोग्राम का उपयोग शामिल है। यह डेटा और सॉफ़्टवेयर एप्लिकेशन के बीच एक इंटरफ़ेस प्रदान करता है।

डीबीएमएस का उदाहरण
-----------------

आइए विश्वविद्यालय डेटाबेस का एक सरल उदाहरण देखें। यह डेटाबेस विश्वविद्यालय परिवेश में छात्रों, पाठ्यक्रमों और ग्रेड से संबंधित जानकारी रखता है। डेटाबेस को पाँच फ़ाइलों में व्यवस्थित किया गया है:

* छात्र फ़ाइल प्रत्येक छात्र का डेटा संग्रहीत करती है
* COURSE फ़ाइल भंडार में प्रत्येक पाठ्यक्रम का डेटा होता है।
* अनुभाग किसी विशेष पाठ्यक्रम के अनुभागों के बारे में जानकारी संग्रहीत करता है।
* GRADE फ़ाइल उन ग्रेडों को संग्रहीत करती है जो छात्रों को विभिन्न अनुभागों में प्राप्त होते हैं
* ट्यूटर फ़ाइल में प्रत्येक प्रोफेसर के बारे में जानकारी होती है।

डीबीएमएस को परिभाषित करने के लिए:

* हमें प्रत्येक रिकॉर्ड में संग्रहीत किए जाने वाले विभिन्न प्रकार के डेटा तत्वों को परिभाषित करके प्रत्येक फ़ाइल के रिकॉर्ड की संरचना को निर्दिष्ट करने की आवश्यकता है।
* हम डेटा आइटम के मूल्यों को दर्शाने के लिए कोडिंग योजना का भी उपयोग कर सकते हैं।
* मूलतः, आपके डेटाबेस में पाँच तालिकाएँ होंगी जिनमें विभिन्न तालिकाओं के बीच एक विदेशी कुंजी परिभाषित होगी।

डीबीएमएस का इतिहास
---------------

यहां इतिहास के महत्वपूर्ण स्थल हैं:

* 1960 - चार्ल्स बैचमैन ने पहला DBMS सिस्टम डिज़ाइन किया
* 1970 - कॉड ने आईबीएम की सूचना प्रबंधन प्रणाली (आईएमएस) की शुरुआत की।
* 1976- पीटर चेन ने इकाई-संबंध मॉडल को गढ़ा और परिभाषित किया, जिसे ईआर मॉडल के रूप में भी जाना जाता है।
* 1980 - रिलेशनल मॉडल एक व्यापक रूप से स्वीकृत डेटाबेस घटक बन गया
* 1985- ऑब्जेक्ट-ओरिएंटेड DBMS विकसित हुआ।
* 1990 का दशक- रिलेशनल डीबीएमएस में ऑब्जेक्ट ओरिएंटेशन का समावेश।
* 1991- माइक्रोसॉफ्ट ने एमएस एक्सेस, एक व्यक्तिगत डीबीएमएस शिप किया जो अन्य सभी व्यक्तिगत डीबीएमएस उत्पादों को विस्थापित करता है।
* 1995: पहला इंटरनेट डेटाबेस एप्लिकेशन
* 1997: XML को डेटाबेस प्रोसेसिंग के लिए लागू किया गया। कई विक्रेता XML को DBMS उत्पादों में एकीकृत करना शुरू करते हैं।

डीबीएमएस के लक्षण
----------------------

यहां डेटाबेस प्रबंधन प्रणाली की विशेषताएं और गुण दिए गए हैं:

* सुरक्षा प्रदान करता है और अतिरेक को दूर करता है
* डेटाबेस प्रणाली की प्रकृति का स्व-वर्णन करना
* प्रोग्राम और डेटा एब्स्ट्रैक्शन के बीच इन्सुलेशन
* डेटा के एकाधिक दृश्यों का समर्थन
* डेटा साझा करना और बहु-उपयोगकर्ता लेनदेन प्रसंस्करण
* डेटाबेस प्रबंधन सॉफ्टवेयर संस्थाओं और उनके बीच संबंधों को तालिकाएँ बनाने की अनुमति देता है।
* यह ACID अवधारणा (परमाणुता, संगति, अलगाव और स्थायित्व) का पालन करता है।
* DBMS एक बहु-उपयोगकर्ता वातावरण का समर्थन करता है जो उपयोगकर्ताओं को समानांतर में डेटा तक पहुंचने और हेरफेर करने की अनुमति देता है।

लोकप्रिय डीबीएमएस सॉफ्टवेयर
----------------------

यहां कुछ लोकप्रिय DBMS सिस्टम की सूची दी गई है:

*   माई एसक्यूएल
*   माइक्रोसॉफ्ट पहुंच
*   आकाशवाणी
* पोस्टग्रेएसक्यूएल
* डीबेस
* फॉक्सप्रो
* SQLite
*आईबीएम डीबी2
* लिब्रे ऑफिस बेस
* मारियाडीबी
* माइक्रोसॉफ्ट एसक्यूएल सर्वर आदि।

## [Cryptography](Cryptography/readme.md#cryptography)
क्रिप्टोग्राफी डेटा और संचार को सुरक्षित करने की एक तकनीक है। यह कोड के उपयोग के माध्यम से सूचना और संचार को सुरक्षित रखने की एक विधि है ताकि केवल वे लोग ही इसे पढ़ और संसाधित कर सकें जिनके लिए जानकारी का इरादा है। क्रिप्टोग्राफी का उपयोग पारगमन, आराम और उपयोग में डेटा की सुरक्षा के लिए किया जाता है। उपसर्ग _क्रिप्ट_ का अर्थ है "छिपा हुआ" या "गुप्त", और प्रत्यय _ग्राफी_ का अर्थ है "लिखना"।

### क्रिप्टोग्राफी के प्रकार
क्रिप्टोग्राफी दो प्रकार की होती है:
1. [Symmetric Cryptography](Cryptography/readme.md#symmetric-cryptography)
2. [Asymmetric Cryptography](Cryptography/readme.md#asymmetric-cryptography)

### [Crypto Currency](Cryptography/CryptoCurrency/readme.md#crypto-currency)
क्रिप्टोकरेंसी एक डिजिटल मुद्रा है जिसमें एन्क्रिप्शन तकनीकों का उपयोग मुद्रा की इकाइयों की पीढ़ी को विनियमित करने और केंद्रीय बैंक से स्वतंत्र रूप से संचालित होने वाले धन के हस्तांतरण को सत्यापित करने के लिए किया जाता है। केंद्रीकृत डिजिटल मुद्रा और केंद्रीय बैंकिंग प्रणालियों के विपरीत क्रिप्टोकरेंसी विकेंद्रीकृत नियंत्रण का उपयोग करती है। प्रत्येक क्रिप्टोकरेंसी का विकेंद्रीकृत नियंत्रण वितरित बहीखाता तकनीक के माध्यम से काम करता है, आमतौर पर एक ब्लॉकचेन, जो सार्वजनिक वित्तीय लेनदेन डेटाबेस के रूप में कार्य करता है। क्रिप्टोकरेंसी की एक परिभाषित विशेषता, और यकीनन इसका सबसे आकर्षक आकर्षण, इसकी जैविक प्रकृति है; यह किसी केंद्रीय प्राधिकरण द्वारा जारी नहीं किया जाता है, जो इसे सैद्धांतिक रूप से सरकारी हस्तक्षेप या हेरफेर से प्रतिरक्षित करता है।

## Types of Crypto Currency are as follows:
1. [Proof of Work](Cryptography/CryptoCurrency/ProofOfWork/readme.md#proof-of-work)
2. [Proof of Stake](Cryptography/CryptoCurrency/ProofOfStake/readme.md#proof-of-stake)



### _Most Popular Crypto Currencies are as follows:_
1. [Bitcoin](Cryptography/CryptoCurrency/ProofOfWork/Bitcoin/readme.md#bitcoin)
2. [Ethereum](Cryptography/CryptoCurrency/ProofOfStake/Ethereum/readme.md#ethereum)
3. [Litecoin](Cryptography/CryptoCurrency/ProofOfWork/Litecoin/readme.md#litecoin)
4. [Cardano](Cryptography/CryptoCurrency/ProofOfStake/Cardano/readme.md#cardano)
5. [Dogecoin](Cryptography/CryptoCurrency/ProofOfWork/Dogecoin/readme.md#dogecoin)



## संगणना का सिद्धांत
सैद्धांतिक कंप्यूटर विज्ञान और गणित में, गणना का सिद्धांत वह शाखा है जो इस बात से संबंधित है कि एल्गोरिदम का उपयोग करके गणना के मॉडल पर किन समस्याओं को हल किया जा सकता है, उन्हें कितनी कुशलता से हल किया जा सकता है, या किस हद तक (उदाहरण के लिए, अनुमानित समाधान बनाम सटीक समाधान) ). क्षेत्र को तीन प्रमुख शाखाओं में विभाजित किया गया है: ऑटोमेटा सिद्धांत और औपचारिक भाषाएं, कम्प्यूटेबिलिटी सिद्धांत, और कम्प्यूटेशनल जटिलता सिद्धांत, जो इस प्रश्न से जुड़े हुए हैं: "कंप्यूटर की मूलभूत क्षमताएं और सीमाएं क्या हैं?"

### ऑटोमेटा सिद्धांत
ऑटोमेटा सिद्धांत अमूर्त मशीनों और ऑटोमेटा के साथ-साथ कम्प्यूटेशनल समस्याओं का अध्ययन है जिन्हें उनका उपयोग करके हल किया जा सकता है। यह सैद्धांतिक कंप्यूटर विज्ञान में एक सिद्धांत है। ऑटोमेटा शब्द ग्रीक शब्द αὐτόματος से आया है, जिसका अर्थ है "स्व-अभिनय, स्व-इच्छाधारी, स्व-चालित"। एक ऑटोमेटन (बहुवचन में ऑटोमेटा) एक अमूर्त स्व-चालित कंप्यूटिंग डिवाइस है जो स्वचालित रूप से संचालन के पूर्व निर्धारित अनुक्रम का पालन करता है। राज्यों की एक सीमित संख्या वाले एक ऑटोमेटन को परिमित ऑटोमेटन (एफए) या परिमित-राज्य मशीन (एफएसएम) कहा जाता है। दाईं ओर का चित्र एक परिमित-राज्य मशीन को दर्शाता है, जो एक प्रसिद्ध प्रकार का ऑटोमेटन है। इस ऑटोमेटन में स्थितियाँ (वृत्तों द्वारा चित्र में दर्शाई गई) और संक्रमण (तीरों द्वारा दर्शाई गई) शामिल हैं। जैसे ही ऑटोमेटन इनपुट का एक प्रतीक देखता है, यह अपने संक्रमण फ़ंक्शन के अनुसार, किसी अन्य राज्य में संक्रमण (या छलांग) करता है, जो पिछले राज्य और वर्तमान इनपुट प्रतीक को अपने तर्क के रूप में लेता है।


### औपचारिक भाषाएँ
तर्क, गणित, कंप्यूटर विज्ञान और भाषा विज्ञान में, एक औपचारिक भाषा में ऐसे शब्द होते हैं जिनके अक्षर वर्णमाला से लिए जाते हैं और नियमों के एक विशिष्ट सेट के अनुसार अच्छी तरह से बनाए जाते हैं।

औपचारिक भाषा की वर्णमाला में प्रतीक, अक्षर या चिह्न होते हैं जो भाषा के तारों में जुड़ते हैं।[1] इस वर्णमाला के प्रतीकों से जुड़ी प्रत्येक स्ट्रिंग को एक शब्द कहा जाता है, और जो शब्द किसी विशेष औपचारिक भाषा से संबंधित होते हैं उन्हें कभी-कभी सुगठित शब्द या सुगठित सूत्र कहा जाता है। एक औपचारिक भाषा को अक्सर औपचारिक व्याकरण का उपयोग करके परिभाषित किया जाता है, जैसे कि नियमित व्याकरण या संदर्भ-मुक्त व्याकरण, जिसमें इसके गठन के नियम शामिल होते हैं।

कंप्यूटर विज्ञान में, औपचारिक भाषाओं का उपयोग, अन्य बातों के अलावा, प्रोग्रामिंग भाषाओं के व्याकरण और प्राकृतिक भाषाओं के सबसेट के औपचारिक संस्करणों को परिभाषित करने के आधार के रूप में किया जाता है, जिसमें भाषा के शब्द उन अवधारणाओं का प्रतिनिधित्व करते हैं जो विशेष अर्थ या शब्दार्थ से जुड़े होते हैं। कम्प्यूटेशनल जटिलता सिद्धांत में, निर्णय समस्याओं को आम तौर पर औपचारिक भाषाओं के रूप में परिभाषित किया जाता है और जटिलता वर्गों को औपचारिक भाषाओं के सेट के रूप में परिभाषित किया जाता है जिन्हें सीमित कम्प्यूटेशनल शक्ति वाली मशीनों द्वारा पार्स किया जा सकता है। तर्क और गणित की नींव में, औपचारिक भाषाओं का उपयोग स्वयंसिद्ध प्रणालियों के वाक्यविन्यास का प्रतिनिधित्व करने के लिए किया जाता है, और गणितीय औपचारिकतावाद वह दर्शन है कि सभी गणित को इस तरह से औपचारिक भाषाओं के वाक्यविन्यास हेरफेर में कम किया जा सकता है।

### संगणना सिद्धांत
कम्प्यूटेबिलिटी सिद्धांत, जिसे रिकर्सन सिद्धांत के रूप में भी जाना जाता है, गणितीय तर्क, कंप्यूटर विज्ञान और गणना के सिद्धांत की एक शाखा है जिसकी उत्पत्ति 1930 के दशक में गणना योग्य कार्यों और ट्यूरिंग डिग्री के अध्ययन के साथ हुई थी। तब से इस क्षेत्र का विस्तार सामान्यीकृत कम्प्यूटेबिलिटी और निश्चितता के अध्ययन को शामिल करने के लिए किया गया है। इन क्षेत्रों में, संगणनीयता सिद्धांत प्रमाण सिद्धांत और प्रभावी वर्णनात्मक सेट सिद्धांत के साथ ओवरलैप होता है।

### कम्प्यूटेशनल जटिलता सिद्धांत
सैद्धांतिक कंप्यूटर विज्ञान और गणित में, कम्प्यूटेशनल जटिलता सिद्धांत उनके संसाधन उपयोग के अनुसार कम्प्यूटेशनल समस्याओं को वर्गीकृत करने और इन वर्गों को एक दूसरे से संबंधित करने पर केंद्रित है। कम्प्यूटेशनल समस्या कंप्यूटर द्वारा हल किया जाने वाला कार्य है। एक गणना समस्या को एल्गोरिदम जैसे गणितीय चरणों के यांत्रिक अनुप्रयोग द्वारा हल किया जा सकता है।

किसी समस्या को स्वाभाविक रूप से कठिन माना जाता है यदि उसके समाधान के लिए महत्वपूर्ण संसाधनों की आवश्यकता होती है, भले ही एल्गोरिदम का उपयोग कुछ भी हो। सिद्धांत इन समस्याओं का अध्ययन करने और उनकी कम्प्यूटेशनल जटिलता की मात्रा निर्धारित करने के लिए गणना के गणितीय मॉडल पेश करके इस अंतर्ज्ञान को औपचारिक बनाता है, यानी, उन्हें हल करने के लिए आवश्यक संसाधनों की संख्या, जैसे समय और भंडारण। जटिलता के अन्य उपायों का भी उपयोग किया जाता है, जैसे संचार की मात्रा (संचार जटिलता में प्रयुक्त), सर्किट में गेटों की संख्या (सर्किट जटिलता में प्रयुक्त), और प्रोसेसर की संख्या (समानांतर कंप्यूटिंग में प्रयुक्त)। कम्प्यूटेशनल जटिलता सिद्धांत की भूमिकाओं में से एक कंप्यूटर क्या कर सकता है और क्या नहीं, इसकी व्यावहारिक सीमाएं निर्धारित करना है। पी बनाम एनपी समस्या, सात सहस्राब्दी पुरस्कार समस्याओं में से एक, कम्प्यूटेशनल जटिलता के क्षेत्र के लिए समर्पित है।[1]

सैद्धांतिक कंप्यूटर विज्ञान में निकटतम संबंधित क्षेत्र एल्गोरिदम और कम्प्यूटेबिलिटी सिद्धांत का विश्लेषण हैं। एल्गोरिदम के विश्लेषण और कम्प्यूटेशनल जटिलता सिद्धांत के बीच एक महत्वपूर्ण अंतर यह है कि पूर्व किसी समस्या को हल करने के लिए किसी विशेष एल्गोरिदम द्वारा आवश्यक संसाधनों की संख्या का विश्लेषण करने के लिए समर्पित है, जबकि बाद वाला उन सभी संभावित एल्गोरिदम के बारे में अधिक सामान्य प्रश्न पूछता है जिनका उपयोग किया जा सकता है। उसी समस्या को हल करने के लिए. अधिक सटीक रूप से, कम्प्यूटेशनल जटिलता सिद्धांत उन समस्याओं को वर्गीकृत करने का प्रयास करता है जिन्हें उचित रूप से प्रतिबंधित संसाधनों के साथ हल किया जा सकता है या नहीं। बदले में, उपलब्ध संसाधनों पर प्रतिबंध लगाना कम्प्यूटेशनल जटिलता को कम्प्यूटेबिलिटी सिद्धांत से अलग करता है: बाद वाला सिद्धांत पूछता है कि सिद्धांत रूप में किस प्रकार की समस्याओं को एल्गोरिदमिक रूप से हल किया जा सकता है।


 
## Contributors

<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tbody>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="http://safayat.me"><img src="https://avatars.githubusercontent.com/u/80335059?v=4?s=50" width="50px;" alt="Sifat"/><br /><sub><b>Sifat</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=shhossain" title="Code">💻</a> <a href="#content-shhossain" title="Content">🖋</a> <a href="https://github.com/shhossain/computer_science/commits?author=shhossain" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Sabine91"><img src="https://avatars.githubusercontent.com/u/96158726?v=4?s=50" width="50px;" alt="Yuvraj Chauhan"/><br /><sub><b>Yuvraj Chauhan</b></sub></a><br /><a href="#content-Sabine91" title="Content">🖋</a> <a href="https://github.com/shhossain/computer_science/commits?author=Sabine91" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Rajesh144142"><img src="https://avatars.githubusercontent.com/u/82487522?v=4?s=50" width="50px;" alt="Rajesh kumar halder"/><br /><sub><b>Rajesh kumar halder</b></sub></a><br /><a href="#content-Rajesh144142" title="Content">🖋</a> <a href="https://github.com/shhossain/computer_science/commits?author=Rajesh144142" title="Code">💻</a> <a href="https://github.com/shhossain/computer_science/commits?author=Rajesh144142" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="http://ishanmondal.me"><img src="https://avatars.githubusercontent.com/u/76674591?v=4?s=50" width="50px;" alt="Ishan Mondal"/><br /><sub><b>Ishan Mondal</b></sub></a><br /><a href="#content-ishan-im" title="Content">🖋</a> <a href="https://github.com/shhossain/computer_science/commits?author=ishan-im" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Apoorva08102000"><img src="https://avatars.githubusercontent.com/u/91753868?v=4?s=50" width="50px;" alt="Apoorva08102000"/><br /><sub><b>Apoorva08102000</b></sub></a><br /><a href="#content-Apoorva08102000" title="Content">🖋</a> <a href="https://github.com/shhossain/computer_science/commits?author=Apoorva08102000" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/apoorva1823000"><img src="https://avatars.githubusercontent.com/u/71769587?v=4?s=50" width="50px;" alt="Apoorva .S. Mehta"/><br /><sub><b>Apoorva .S. Mehta</b></sub></a><br /><a href="#content-apoorva1823000" title="Content">🖋</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/utopian-coder"><img src="https://avatars.githubusercontent.com/u/66299782?v=4?s=50" width="50px;" alt="Imran Biswas"/><br /><sub><b>Imran Biswas</b></sub></a><br /><a href="#content-utopian-coder" title="Content">🖋</a> <a href="https://github.com/shhossain/computer_science/commits?author=utopian-coder" title="Code">💻</a> <a href="https://github.com/shhossain/computer_science/commits?author=utopian-coder" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/subrata-9999"><img src="https://avatars.githubusercontent.com/u/109057053?v=4?s=50" width="50px;" alt="Subrata Pramanik"/><br /><sub><b>Subrata Pramanik</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=subrata-9999" title="Code">💻</a> <a href="https://github.com/shhossain/computer_science/commits?author=subrata-9999" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://br.linkedin.com/in/samuelbratifavarin"><img src="https://avatars.githubusercontent.com/u/17628602?v=4?s=50" width="50px;" alt="Samuel Favarin"/><br /><sub><b>Samuel Favarin</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=SamuelBFavarin" title="Documentation">📖</a> <a href="https://github.com/shhossain/computer_science/commits?author=SamuelBFavarin" title="Code">💻</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/sahooabhipsa10"><img src="https://avatars.githubusercontent.com/u/99355886?v=4?s=50" width="50px;" alt="sahooabhipsa10"/><br /><sub><b>sahooabhipsa10</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=sahooabhipsa10" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Sahilrao09"><img src="https://avatars.githubusercontent.com/u/88286056?v=4?s=50" width="50px;" alt="Sahil Rao"/><br /><sub><b>Sahil Rao</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Sahilrao09" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Code-N-Bug"><img src="https://avatars.githubusercontent.com/u/103832013?v=4?s=50" width="50px;" alt="K K Chowdhury"/><br /><sub><b>K K Chowdhury</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Code-N-Bug" title="Code">💻</a> <a href="https://github.com/shhossain/computer_science/commits?author=Code-N-Bug" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://manas6699.github.io/portfolio-website3.0/"><img src="https://avatars.githubusercontent.com/u/78929050?v=4?s=50" width="50px;" alt="Manas Baroi"/><br /><sub><b>Manas Baroi</b></sub></a><br /><a href="#example-manas6699" title="Examples">💡</a> <a href="https://github.com/shhossain/computer_science/commits?author=manas6699" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/kanaujiyaaditi"><img src="https://avatars.githubusercontent.com/u/94130073?v=4?s=50" width="50px;" alt="Aditi"/><br /><sub><b>Aditi</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=kanaujiyaaditi" title="Documentation">📖</a> <a href="#content-kanaujiyaaditi" title="Content">🖋</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Talib-Hossain"><img src="https://avatars.githubusercontent.com/u/83373885?v=4?s=50" width="50px;" alt="Syed Talib Hossain"/><br /><sub><b>Syed Talib Hossain</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Talib-Hossain" title="Code">💻</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/JaiMehrotra02"><img src="https://avatars.githubusercontent.com/u/94130223?v=4?s=50" width="50px;" alt="Jai Mehrotra"/><br /><sub><b>Jai Mehrotra</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=JaiMehrotra02" title="Documentation">📖</a> <a href="https://github.com/shhossain/computer_science/commits?author=JaiMehrotra02" title="Code">💻</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/ShuvamBag"><img src="https://avatars.githubusercontent.com/u/82321197?v=4?s=50" width="50px;" alt="Shuvam Bag"/><br /><sub><b>Shuvam Bag</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=ShuvamBag" title="Code">💻</a> <a href="https://github.com/shhossain/computer_science/commits?author=ShuvamBag" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/AbhijitTurate"><img src="https://avatars.githubusercontent.com/u/46615905?v=4?s=50" width="50px;" alt="Abhijit Turate"/><br /><sub><b>Abhijit Turate</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=AbhijitTurate" title="Code">💻</a> <a href="https://github.com/shhossain/computer_science/commits?author=AbhijitTurate" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Jayesh2812"><img src="https://avatars.githubusercontent.com/u/52153715?v=4?s=50" width="50px;" alt="Jayesh Deorukhkar"/><br /><sub><b>Jayesh Deorukhkar</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Jayesh2812" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/SohamDey80"><img src="https://avatars.githubusercontent.com/u/93932583?v=4?s=50" width="50px;" alt="JC Shankar"/><br /><sub><b>JC Shankar</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=SohamDey80" title="Code">💻</a> <a href="https://github.com/shhossain/computer_science/commits?author=SohamDey80" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Subrata-Pramanik"><img src="https://avatars.githubusercontent.com/u/86642230?v=4?s=50" width="50px;" alt="Subrata Pramanik"/><br /><sub><b>Subrata Pramanik</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Subrata-Pramanik" title="Code">💻</a> <a href="https://github.com/shhossain/computer_science/commits?author=Subrata-Pramanik" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/imams12"><img src="https://avatars.githubusercontent.com/u/59444865?v=4?s=50" width="50px;" alt="Imam Suyuti"/><br /><sub><b>Imam Suyuti</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=imams12" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/rahulmangla28"><img src="https://avatars.githubusercontent.com/u/93324315?v=4?s=50" width="50px;" alt="genius_koder"/><br /><sub><b>genius_koder</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=rahulmangla28" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://www.altafshaikh.ml"><img src="https://avatars.githubusercontent.com/u/26015187?v=4?s=50" width="50px;" alt="Altaf Shaikh"/><br /><sub><b>Altaf Shaikh</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=altafshaikh" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/rajdeepdas2000"><img src="https://avatars.githubusercontent.com/u/53941109?v=4?s=50" width="50px;" alt="Rajdeep Das"/><br /><sub><b>Rajdeep Das</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=rajdeepdas2000" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/its-red-eagle"><img src="https://avatars.githubusercontent.com/u/77643994?v=4?s=50" width="50px;" alt="Vikash Patel"/><br /><sub><b>Vikash Patel</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=its-red-eagle" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/alwenpy"><img src="https://avatars.githubusercontent.com/u/94129388?v=4?s=50" width="50px;" alt="Arvind Srivastav"/><br /><sub><b>Arvind Srivastav</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=alwenpy" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Naprila"><img src="https://avatars.githubusercontent.com/u/85901005?v=4?s=50" width="50px;" alt="Manish Kr Prasad"/><br /><sub><b>Manish Kr Prasad</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Naprila" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://linktr.ee/mohit_kushwaha"><img src="https://avatars.githubusercontent.com/u/73400792?v=4?s=50" width="50px;" alt="MOHIT KUMAR KUSHWAHA"/><br /><sub><b>MOHIT KUMAR KUSHWAHA</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=KimtVak8143" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/DryHitman"><img src="https://avatars.githubusercontent.com/u/116108787?v=4?s=50" width="50px;" alt="DryHitman"/><br /><sub><b>DryHitman</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=DryHitman" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/harshkulkarni17"><img src="https://avatars.githubusercontent.com/u/72391096?v=4?s=50" width="50px;" alt="Harsh Kulkarni"/><br /><sub><b>Harsh Kulkarni</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=harshkulkarni17" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/ATREAY"><img src="https://avatars.githubusercontent.com/u/66585295?v=4?s=50" width="50px;" alt="Atreay  Kukanur"/><br /><sub><b>Atreay  Kukanur</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=ATREAY" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://sreeharan.github.io"><img src="https://avatars.githubusercontent.com/u/62993067?v=4?s=50" width="50px;" alt="Sree Haran"/><br /><sub><b>Sree Haran</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=SreeHaran" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://www.linkedin.com/in/auro-saswat-raj-d05m07y2003/"><img src="https://avatars.githubusercontent.com/u/83534307?v=4?s=50" width="50px;" alt="Auro Saswat Raj"/><br /><sub><b>Auro Saswat Raj</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=geeky-auro" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Aiyan-Faras"><img src="https://avatars.githubusercontent.com/u/55203889?v=4?s=50" width="50px;" alt="Aiyan Faras"/><br /><sub><b>Aiyan Faras</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Aiyan-Faras" title="Documentation">📖</a> <a href="https://github.com/shhossain/computer_science/commits?author=Aiyan-Faras" title="Code">💻</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/PriyanshiDavid"><img src="https://avatars.githubusercontent.com/u/71930453?v=4?s=50" width="50px;" alt="Priyanshi David"/><br /><sub><b>Priyanshi David</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=PriyanshiDavid" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/ishancode-dev"><img src="https://avatars.githubusercontent.com/u/115942220?v=4?s=50" width="50px;" alt="Ishan Mondal"/><br /><sub><b>Ishan Mondal</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=ishancode-dev" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="http://expy.bio/NikhilShrivastava"><img src="https://avatars.githubusercontent.com/u/20610444?v=4?s=50" width="50px;" alt="Nikhil Shrivastava"/><br /><sub><b>Nikhil Shrivastava</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=NikhilShrivastava" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/deepshikha2708"><img src="https://avatars.githubusercontent.com/u/80972038?v=4?s=50" width="50px;" alt="deepshikha2708"/><br /><sub><b>deepshikha2708</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=deepshikha2708" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/rishiwardhan"><img src="https://avatars.githubusercontent.com/u/88772100?v=4?s=50" width="50px;" alt="L.RISHIWARDHAN"/><br /><sub><b>L.RISHIWARDHAN</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=rishiwardhan" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/DevTMK"><img src="https://avatars.githubusercontent.com/u/47377566?v=4?s=50" width="50px;" alt="Rahul RK"/><br /><sub><b>Rahul RK</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=DevTMK" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://www.linkedin.com/company/nscc-ggv/"><img src="https://avatars.githubusercontent.com/u/82573863?v=4?s=50" width="50px;" alt="Nishant Wankhade"/><br /><sub><b>Nishant Wankhade</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=NishantWankhade" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/pritika163"><img src="https://avatars.githubusercontent.com/u/102177744?v=4?s=50" width="50px;" alt="pritika163"/><br /><sub><b>pritika163</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=pritika163" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/AnjumanHasan"><img src="https://avatars.githubusercontent.com/u/82674743?v=4?s=50" width="50px;" alt="Anjuman Hasan"/><br /><sub><b>Anjuman Hasan</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=AnjumanHasan" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://linktr.ee/asthavarshney"><img src="https://avatars.githubusercontent.com/u/97240696?v=4?s=50" width="50px;" alt="Astha Varshney "/><br /><sub><b>Astha Varshney </b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Asthavarshneyy" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Gcettbdeveloper"><img src="https://avatars.githubusercontent.com/u/114204175?v=4?s=50" width="50px;" alt="Gcettbdeveloper"/><br /><sub><b>Gcettbdeveloper</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Gcettbdeveloper" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://elston-website.web.app"><img src="https://avatars.githubusercontent.com/u/66341506?v=4?s=50" width="50px;" alt="Elston Tan"/><br /><sub><b>Elston Tan</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Elstuhn" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/ShivanshDengla"><img src="https://avatars.githubusercontent.com/u/66008449?v=4?s=50" width="50px;" alt="Shivansh Dengla"/><br /><sub><b>Shivansh Dengla</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=ShivanshDengla" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://www.tetricz.com"><img src="https://avatars.githubusercontent.com/u/49681400?v=4?s=50" width="50px;" alt="David Daniels"/><br /><sub><b>David Daniels</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Tetricz" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/ayushverma14"><img src="https://avatars.githubusercontent.com/u/65187507?v=4?s=50" width="50px;" alt="ayushverma14"/><br /><sub><b>ayushverma14</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=ayushverma14" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://kontentkreator.tech"><img src="https://avatars.githubusercontent.com/u/70800059?v=4?s=50" width="50px;" alt="Pratik Rai"/><br /><sub><b>Pratik Rai</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=pratikkumar399" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/yash-ch"><img src="https://avatars.githubusercontent.com/u/66888087?v=4?s=50" width="50px;" alt="Yash"/><br /><sub><b>Yash</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=yash-ch" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/pranavyatnalkar"><img src="https://avatars.githubusercontent.com/u/84735288?v=4?s=50" width="50px;" alt="pranavyatnalkar"/><br /><sub><b>pranavyatnalkar</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=pranavyatnalkar" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/jeremiaaxel"><img src="https://avatars.githubusercontent.com/u/57858415?v=4?s=50" width="50px;" alt="Jeremia Axel"/><br /><sub><b>Jeremia Axel</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=jeremiaaxel" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://in.linkedin.com/in/akhil-soni-9827181a1"><img src="https://avatars.githubusercontent.com/u/58397226?v=4?s=50" width="50px;" alt="Akhil Soni"/><br /><sub><b>Akhil Soni</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=akhil-maker" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/DevZahraShahid"><img src="https://avatars.githubusercontent.com/u/111266434?v=4?s=50" width="50px;" alt="Zahra Shahid"/><br /><sub><b>Zahra Shahid</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=DevZahraShahid" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Mihir20K"><img src="https://avatars.githubusercontent.com/u/112269999?v=4?s=50" width="50px;" alt="Mihir20K"/><br /><sub><b>Mihir20K</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Mihir20K" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/computerwala"><img src="https://avatars.githubusercontent.com/u/30777038?v=4?s=50" width="50px;" alt="Aman"/><br /><sub><b>Aman</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=computerwala" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/mauriallegrettiswnat"><img src="https://avatars.githubusercontent.com/u/71467262?v=4?s=50" width="50px;" alt="Mauricio Allegretti"/><br /><sub><b>Mauricio Allegretti</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=mauriallegrettiswnat" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Bruno-Vasconcellos-Betella"><img src="https://avatars.githubusercontent.com/u/57138664?v=4?s=50" width="50px;" alt="Bruno-Vasconcellos-Betella"/><br /><sub><b>Bruno-Vasconcellos-Betella</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Bruno-Vasconcellos-Betella" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://itdadakan.site"><img src="https://avatars.githubusercontent.com/u/62456215?v=4?s=50" width="50px;" alt="Febi Arifin"/><br /><sub><b>Febi Arifin</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=febiarifin" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/dinesh9-ai"><img src="https://avatars.githubusercontent.com/u/63300423?v=4?s=50" width="50px;" alt="Dineshwar Doddapaneni"/><br /><sub><b>Dineshwar Doddapaneni</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=dinesh9-ai" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Dheerajsoni93"><img src="https://avatars.githubusercontent.com/u/82114565?v=4?s=50" width="50px;" alt="Dheeraj_Soni"/><br /><sub><b>Dheeraj_Soni</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Dheerajsoni93" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://www.linkedin.com/in/ojash-kushwaha-791770185"><img src="https://avatars.githubusercontent.com/u/96474959?v=4?s=50" width="50px;" alt="Ojash Kushwaha"/><br /><sub><b>Ojash Kushwaha</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=OjashKush" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Sleep-lover"><img src="https://avatars.githubusercontent.com/u/82304155?v=4?s=50" width="50px;" alt="Laleet Borse"/><br /><sub><b>Laleet Borse</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Sleep-lover" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Wahaj-Raza"><img src="https://avatars.githubusercontent.com/u/103155321?v=4?s=50" width="50px;" alt="Wahaj Raza"/><br /><sub><b>Wahaj Raza</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Wahaj-Raza" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/WahajRaza1"><img src="https://avatars.githubusercontent.com/u/90937190?v=4?s=50" width="50px;" alt="WahajRaza1"/><br /><sub><b>WahajRaza1</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=WahajRaza1" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://ravencolevol.github.io"><img src="https://avatars.githubusercontent.com/u/44892121?v=4?s=50" width="50px;" alt="Ravi Lamkoti"/><br /><sub><b>Ravi Lamkoti</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=RavenColEvol" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/UperscuzziSchoolAcc"><img src="https://avatars.githubusercontent.com/u/111448336?v=4?s=50" width="50px;" alt="The One and Only Uper"/><br /><sub><b>The One and Only Uper</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=UperscuzziSchoolAcc" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/AdarshBajpai67"><img src="https://avatars.githubusercontent.com/u/95476086?v=4?s=50" width="50px;" alt="AdarshBajpai67"/><br /><sub><b>AdarshBajpai67</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=AdarshBajpai67" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="http://deepakkharah.me"><img src="https://avatars.githubusercontent.com/u/42672761?v=4?s=50" width="50px;" alt="Deepak Kharah"/><br /><sub><b>Deepak Kharah</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Deepak-Kharah" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/sairohit360"><img src="https://avatars.githubusercontent.com/u/55144209?v=4?s=50" width="50px;" alt="sairohit360"/><br /><sub><b>sairohit360</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=sairohit360" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/sairohitzl"><img src="https://avatars.githubusercontent.com/u/86225259?v=4?s=50" width="50px;" alt="sairohitzl"/><br /><sub><b>sairohitzl</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=sairohitzl" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/RavalJinit"><img src="https://avatars.githubusercontent.com/u/72157334?v=4?s=50" width="50px;" alt="Raval Jinit"/><br /><sub><b>Raval Jinit</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=RavalJinit" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Vovka1759"><img src="https://avatars.githubusercontent.com/u/75867274?v=4?s=50" width="50px;" alt="Vovka1759"/><br /><sub><b>Vovka1759</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Vovka1759" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Nijin-P-S"><img src="https://avatars.githubusercontent.com/u/101330853?v=4?s=50" width="50px;" alt="Nijin"/><br /><sub><b>Nijin</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Nijin-P-S" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/avinilcode"><img src="https://avatars.githubusercontent.com/u/111761529?v=4?s=50" width="50px;" alt="Avinil Bedarkar"/><br /><sub><b>Avinil Bedarkar</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=avinilcode" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/FercueNat"><img src="https://avatars.githubusercontent.com/u/113535859?v=4?s=50" width="50px;" alt="FercueNat"/><br /><sub><b>FercueNat</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=FercueNat" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://khareyash05.github.io/home/"><img src="https://avatars.githubusercontent.com/u/60147732?v=4?s=50" width="50px;" alt="Yash Khare"/><br /><sub><b>Yash Khare</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=khareyash05" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/ayushanand16"><img src="https://avatars.githubusercontent.com/u/96689639?v=4?s=50" width="50px;" alt="Ayush Anand"/><br /><sub><b>Ayush Anand</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=ayushanand16" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/DharmaWarrior"><img src="https://avatars.githubusercontent.com/u/97218268?v=4?s=50" width="50px;" alt="DharmaWarrior"/><br /><sub><b>DharmaWarrior</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=DharmaWarrior" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://linktr.ee/hitarthraval"><img src="https://avatars.githubusercontent.com/u/62943532?v=4?s=50" width="50px;" alt="Hitarth Raval"/><br /><sub><b>Hitarth Raval</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=hitarthraval" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/WiemBorchani"><img src="https://avatars.githubusercontent.com/u/52404192?v=4?s=50" width="50px;" alt="Wiem Borchani "/><br /><sub><b>Wiem Borchani </b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=WiemBorchani" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Kambo2320"><img src="https://avatars.githubusercontent.com/u/98479408?v=4?s=50" width="50px;" alt="Kamden Burke"/><br /><sub><b>Kamden Burke</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Kambo2320" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/denschiro"><img src="https://avatars.githubusercontent.com/u/6161324?v=4?s=50" width="50px;" alt="denschiro"/><br /><sub><b>denschiro</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=denschiro" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/nishat48"><img src="https://avatars.githubusercontent.com/u/109063023?v=4?s=50" width="50px;" alt="Nishat"/><br /><sub><b>Nishat</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=nishat48" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/mdfaizanahmed786"><img src="https://avatars.githubusercontent.com/u/85175130?v=4?s=50" width="50px;" alt="Mohammed Faizan Ahmed"/><br /><sub><b>Mohammed Faizan Ahmed</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=mdfaizanahmed786" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/manish831"><img src="https://avatars.githubusercontent.com/u/74316266?v=4?s=50" width="50px;" alt="Manish Agrahari"/><br /><sub><b>Manish Agrahari</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=manish831" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/lokesh-katari"><img src="https://avatars.githubusercontent.com/u/111894942?v=4?s=50" width="50px;" alt="Katari Lokeswara rao"/><br /><sub><b>Katari Lokeswara rao</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=lokesh-katari" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://g.dev/ZahraShahid"><img src="https://avatars.githubusercontent.com/u/65255043?v=4?s=50" width="50px;" alt="Zahra Shahid"/><br /><sub><b>Zahra Shahid</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=ZahraShahid" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/glenntu15"><img src="https://avatars.githubusercontent.com/u/10324492?v=4?s=50" width="50px;" alt="Glenn Turner"/><br /><sub><b>Glenn Turner</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=glenntu15" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/vinayak9303"><img src="https://avatars.githubusercontent.com/u/55548976?v=4?s=50" width="50px;" alt="Vinayak godse"/><br /><sub><b>Vinayak godse</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=vinayak9303" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Satyajeetbh"><img src="https://avatars.githubusercontent.com/u/88246318?v=4?s=50" width="50px;" alt="Satyajeetbh"/><br /><sub><b>Satyajeetbh</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Satyajeetbh" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/P-Dhruva-Teja"><img src="https://avatars.githubusercontent.com/u/81409709?v=4?s=50" width="50px;" alt="Paidipelly Dhruvateja"/><br /><sub><b>Paidipelly Dhruvateja</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=P-Dhruva-Teja" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/helloausrine"><img src="https://avatars.githubusercontent.com/u/30316810?v=4?s=50" width="50px;" alt="helloausrine"/><br /><sub><b>helloausrine</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=helloausrine" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/SourabhJoshi209"><img src="https://avatars.githubusercontent.com/u/69594540?v=4?s=50" width="50px;" alt="SourabhJoshi209"/><br /><sub><b>SourabhJoshi209</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=SourabhJoshi209" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://bio.link/stefantaitano"><img src="https://avatars.githubusercontent.com/u/85418632?v=4?s=50" width="50px;" alt="Stefan Taitano"/><br /><sub><b>Stefan Taitano</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=codewithfan" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="http://linkedin.com/in/anmspro"><img src="https://avatars.githubusercontent.com/u/33668152?v=4?s=50" width="50px;" alt="Abu Noman Md. Sakib"/><br /><sub><b>Abu Noman Md. Sakib</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=anmspro" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="http://skyrunner360.pythonanywhere.com"><img src="https://avatars.githubusercontent.com/u/44318840?v=4?s=50" width="50px;" alt="Rishi Mathur"/><br /><sub><b>Rishi Mathur</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=skyrunner360" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Atharv-Nalwade"><img src="https://avatars.githubusercontent.com/u/98139553?v=4?s=50" width="50px;" alt="Darky001"/><br /><sub><b>Darky001</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Atharv-Nalwade" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Retr0Sushi"><img src="https://avatars.githubusercontent.com/u/110653014?v=4?s=50" width="50px;" alt="himanshu"/><br /><sub><b>himanshu</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Retr0Sushi" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/kusumita29"><img src="https://avatars.githubusercontent.com/u/99873488?v=4?s=50" width="50px;" alt="Kusumita Ghose"/><br /><sub><b>Kusumita Ghose</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=kusumita29" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Yash1107"><img src="https://avatars.githubusercontent.com/u/76468153?v=4?s=50" width="50px;" alt="Yashvi Patel"/><br /><sub><b>Yashvi Patel</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Yash1107" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/ArshadAriff"><img src="https://avatars.githubusercontent.com/u/113685884?v=4?s=50" width="50px;" alt="ArshadAriff"/><br /><sub><b>ArshadAriff</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=ArshadAriff" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/ishashukla183"><img src="https://avatars.githubusercontent.com/u/93022787?v=4?s=50" width="50px;" alt="ishashukla183"/><br /><sub><b>ishashukla183</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=ishashukla183" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/jhuynh06"><img src="https://avatars.githubusercontent.com/u/111946833?v=4?s=50" width="50px;" alt="jhuynh06"/><br /><sub><b>jhuynh06</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/issues?q=author%3Ajhuynh06" title="Bug reports">🐛</a> <a href="https://github.com/shhossain/computer_science/commits?author=jhuynh06" title="Tests">⚠️</a></td>
      <td align="center" valign="top" width="16.66%"><a href="http://asche.tech"><img src="https://avatars.githubusercontent.com/u/2975712?v=4?s=50" width="50px;" alt="Andrew Asche"/><br /><sub><b>Andrew Asche</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=andrewasche" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="http://nateonmission.github.io"><img src="https://avatars.githubusercontent.com/u/37854313?v=4?s=50" width="50px;" alt="J. Nathan Allen"/><br /><sub><b>J. Nathan Allen</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/issues?q=author%3Anateonmission" title="Bug reports">🐛</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Sayed-Afnan-Khazi"><img src="https://avatars.githubusercontent.com/u/83779299?v=4?s=50" width="50px;" alt="Sayed Afnan Khazi"/><br /><sub><b>Sayed Afnan Khazi</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Sayed-Afnan-Khazi" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Technic143"><img src="https://avatars.githubusercontent.com/u/117275755?v=4?s=50" width="50px;" alt="Technic143"/><br /><sub><b>Technic143</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Technic143" title="Documentation">📖</a> <a href="https://github.com/shhossain/computer_science/issues?q=author%3ATechnic143" title="Bug reports">🐛</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/snowflake1201"><img src="https://avatars.githubusercontent.com/u/56119216?v=4?s=50" width="50px;" alt="Pin Yuan Wang"/><br /><sub><b>Pin Yuan Wang</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=snowflake1201" title="Code">💻</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/BogdanOtava"><img src="https://avatars.githubusercontent.com/u/103674688?v=4?s=50" width="50px;" alt="Bogdan Otava"/><br /><sub><b>Bogdan Otava</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=BogdanOtava" title="Code">💻</a> <a href="https://github.com/shhossain/computer_science/commits?author=BogdanOtava" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Vedeesh6"><img src="https://avatars.githubusercontent.com/u/88491153?v=4?s=50" width="50px;" alt="Vedeesh Dwivedi"/><br /><sub><b>Vedeesh Dwivedi</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/issues?q=author%3AVedeesh6" title="Bug reports">🐛</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/TsiG-404"><img src="https://avatars.githubusercontent.com/u/74056836?v=4?s=50" width="50px;" alt="Tsig"/><br /><sub><b>Tsig</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=TsiG-404" title="Code">💻</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://brandonawan.github.io/Resume/"><img src="https://avatars.githubusercontent.com/u/74030681?v=4?s=50" width="50px;" alt="Brandon Awan"/><br /><sub><b>Brandon Awan</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Brandonawan" title="Documentation">📖</a> <a href="https://github.com/shhossain/computer_science/issues?q=author%3ABrandonawan" title="Bug reports">🐛</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Evy04"><img src="https://avatars.githubusercontent.com/u/84919650?v=4?s=50" width="50px;" alt="Sanya Madre"/><br /><sub><b>Sanya Madre</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Evy04" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/steventohme"><img src="https://avatars.githubusercontent.com/u/56594084?v=4?s=50" width="50px;" alt="Steven"/><br /><sub><b>Steven</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=steventohme" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://www.linkedin.com/in/garrett-crowley-a0b931126/"><img src="https://avatars.githubusercontent.com/u/86014840?v=4?s=50" width="50px;" alt="Garrett Crowley"/><br /><sub><b>Garrett Crowley</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=crowleyg" title="Code">💻</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Francesco601"><img src="https://avatars.githubusercontent.com/u/130352141?v=4?s=50" width="50px;" alt="Francesco Franco"/><br /><sub><b>Francesco Franco</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/issues?q=author%3AFrancesco601" title="Bug reports">🐛</a> <a href="https://github.com/shhossain/computer_science/commits?author=Francesco601" title="Code">💻</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/aclittle096"><img src="https://avatars.githubusercontent.com/u/43685369?v=4?s=50" width="50px;" alt="Alexander Little"/><br /><sub><b>Alexander Little</b></sub></a><br /><a href="#content-aclittle096" title="Content">🖋</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Wandererr01"><img src="https://avatars.githubusercontent.com/u/129178279?v=4?s=50" width="50px;" alt="Subham Maji"/><br /><sub><b>Subham Maji</b></sub></a><br /><a href="#content-Wandererr01" title="Content">🖋</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/ZRX-SIGMA"><img src="https://avatars.githubusercontent.com/u/100613008?v=4?s=50" width="50px;" alt="SK Jiyad"/><br /><sub><b>SK Jiyad</b></sub></a><br /><a href="#content-ZRX-SIGMA" title="Content">🖋</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/exrol"><img src="https://avatars.githubusercontent.com/u/86170495?v=4?s=50" width="50px;" alt="exrol"/><br /><sub><b>exrol</b></sub></a><br /><a href="#content-exrol" title="Content">🖋</a></td>
    </tr>
  </tbody>
</table>

<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->

<!-- ALL-CONTRIBUTORS-LIST:END -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->

<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->

<!-- ALL-CONTRIBUTORS-LIST:END -->
<!-- ALL-CONTRIBUTORS-BADGE:START - Do not remove or modify this section -->

[![All Contributors](https://img.shields.io/badge/all_contributors-104-orange.svg?style=flat-square)](#contributors)
<!-- ALL-CONTRIBUTORS-BADGE:END -->
